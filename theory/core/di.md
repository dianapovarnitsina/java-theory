### Оглавление

[//]: # (+ [Общие определения]&#40;#Общие-определения&#41;)

[//]: # ()
[//]: # ()
[//]: # (### Общие определения)


## Dependency Injection (DI)

`Dependency` – зависимость (объект, на который ссылаемся)

`Injection` – подстановка (внедрение)

`Dependency Injection` – это способ создания кода, который позволяет исключить “hard-coded” (явно закодированное) связывание объектов.

`Постулаты DI:` <br>
1) объект лучше передавать извне, чем создавать в месте применения.
2) созданием и внедрением объектов должен заниматься специальный настраиваемый контейнер.

***Способы внедрения объектов:***

1) вручную
   * manual dependency injection <br>
   * в этом случае создание объектов происходит явно в коде на этапе компиляции (во время разработки, до запуска приложения)
   * все равно присутствует элемент hard-code


2) автоматически <br>
   * container dependency injection 
   * внедрение c помощью специального внешнего контейнера
   * возможность настроек и доп. возможностей
   * в этом случае создание объектов происходит на этапе runtime (после запуска приложения)
   * более предпочтительный вариант, чем вручную


## Зачем нужен DI

1) главная причина – слабое (неявное) связывание объектов в коде – low coupling – не будет “закостенелости” https://medium.com/german-gorelkin/low-coupling-high-cohesion-d36369fb1be9
2) делает код более гибким и универсальным – с помощью настроек без вмешательства в код можно изменить работу приложения, связи объектов
3) легче читать код (т.к. меньше самого кода и лишних строк, где создаются объекты и присваиваются друг в друга)
4) более удобное тестирование, рефакторинг – можно “подставлять” в ссылки разные объекты и проверять работу

   
Dependency Injector – внутренний механизм, который распределяет ссылки и объекты

![Image alt](https://raw.githubusercontent.com/dianapovarnitsina/java-theory/master/theory/BD/di.png)

DI более полезен в веб или мобильных приложениях, т.к. там есть архитектура (уровни, слои).<br>
Особенно активно используется DI в Spring и других современных фреймворках.


## Контейнер DI

Внешний контейнер – это обычно библиотека, которая подключается к любому проекту.

Чтобы он заработал – нужно его настроить (через файлы или в коде).

Контейнер:
* создает нужные количество объектов
* внедряет их в приложение
* управляет жизненным циклом всех объектов (lifecycle)
* и делает много другое

После отработки контейнера – приложение может начинать свою работу, т.к. все объекты созданы и внедрены в нужные места.


## Библиотеки и спецификации DI

В Java эта технология называется немного по-другому: CDI – Contexts and Dependency Injection.

DI и CDI – это одно и тоже по смыслу. 

Существует большое количество CDI библиотек, которые берут на себя управляющие функции контейнера:

    Spring Framework
    Guice
    Dagger
    Weld
    и др.

Некоторые лучше подходят для мобильных приложений, некоторые – для веб.

Во многих библиотеках существует настройка, на каком именно этапе выполнять внедрение (compile, runtime).


Полная документация по CDI: https://docs.jboss.org/weld/reference/latest/en-US/html_single/

В приложениях могут одновременно использоваться и new и DI – они друг друга не исключают полностью.

Только нужно понимать, что через new – объект не попадет в DI контейнер (если только не использовать @Produces – об этом в след. уроке)

По-умолчанию CDI контейнер внедряет один и тот же объект.

С помощью @Produces мы можем реализовать, чтобы при каждом @Inject внедрялся новый объект.


## DI и JavaSE

DI более полезен в веб или мобильных приложениях:

1) набор объектов, которые получают из БД – не являются бинами, это обычные POJO (“расходные материалы”) – для отображения данных на страницах – их необязательно добавлять в CDI
2) бинами являются: обработчики событий, специальные сервисы и пр. – составляют костяк архитектуры
3) в JavaSE трудно реализовать примеры DI, т.к. они будут избыточными (из-за того, что нет UI и пользователя, который будет изменять значения объектов, нет архитектуры приложения)

![Image alt](https://raw.githubusercontent.com/dianapovarnitsina/java-theory/master/theory/BD/di2.png)


## Понятие Inversion of Control (IoC)

IoC (inversion of control – инверсия контроля) – принцип работы проекта, при котором поток управления (частично или полностью) передается внешнему инструменту (фреймворку).

Inversion of Control (IoC) и Dependency Injection (DI) часто упоминаются вместе – они позволяют создавать меньше явных связей, код получается более универсальный, конкретные объекты можно подставлять с помощью настроек (файлов, аннотаций)

![Image alt](https://raw.githubusercontent.com/dianapovarnitsina/java-theory/master/theory/BD/IoC.png)

IoC – это принцип построения системы, рекомендации для написания слабосвязанного кода.

Dependency Injection (DI) – это конкретный инструмент для достижения целей IoC.

Помимо DI существуют еще и другие способы (паттерны проектирования) достижения IoC.

Паттерн (шаблон) – это определенная структура кода для достижения какой-либо цели.

На этой картинке перечислены некоторые паттерны (в том числе DI), которые помогают достичь принципов IoC.

Например, Abstract Factory – это отдельный объект-менеджер, который занимается только созданием других объектов (фабрика объектов). 
Таким образом сами объекты не знают кто и как их будет создавать и связывать – этим занимает спец. фабрика. Где тут IoC – объекты не управляют собой, а они управляются отдельно менеджером.

