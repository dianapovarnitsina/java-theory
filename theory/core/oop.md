### Оглавление

+ [Парадигмы](#Парадигмы)
+ [Компиляция и запуск](#Компиляция-и-запуск)
+ [Наследование](#Наследование)

### Парадигмы

Различные подходы к созданию программ называются парадигмами.<br>
Есит две основные парадигмы программирования:
- императивная
- декларативная.

`Императивная парадигма` фокусируется на достижении результата с помощью пошаговых инструкций, которые последовательно изменяют данные.
Императивная парадигма включает:
- парадигма процедурного программирования: основана на концепции вызовов процедур, в которых операторы структурированы в процедуры (C, Java, C++, ColdFusion, Pascal)
- объектно-ориентированное программирование (Ruby, Java, C++, Python, Simula (первый язык ООП), Smalltalk, Visual Basic .NET, Objective-C.)
- подход к параллельной обработке: достигается за счет совместного использования или распараллеливания инструкций между несколькими процессорами (NESL (один из старейших) и C/C++ (также поддерживается благодаря некоторым библиотечным функциям))

`Декларативная парадигма` фокусируется на задаче и пытается получить ожидаемый результат.
Декларативная парадигма включает в себя:
- логику (логическое программирование): основанная на математической логике — программы в ней задаются в форме логических утверждений и правил вывода (Пролог, Программирование наборов ответов (ASP) и Datalog)
- функциональность (функциональное программирование) - это парадигма программирования, в которой процесс вычислений интерпретируется как вычисление значений функций. Функция в этом случае аналогична математической. То есть функция, в которой вход — массив, который не изменяется, а выход — новый массив с новыми данными. Это отличает математическую функцию от функции в процедурном программировании, где функция представляет собой последовательность действий, изменяющих исходные данные (JavaScript, Haskell, Scala, Erlang, Lisp, ML, Clojure, OCaml, Common Lisp и F#)
- парадигму базы данных (парадигма програм-я баз данных) методология программирования основана на работе с данными


**Java реализует:**
- парадигму процедурного программирования
- ооп

![Image alt](https://raw.githubusercontent.com/dianapovarnitsina/java-theory/master/theory/img/paradigms.png)


### Компиляция и запуск

Разработчики пишут исходный код программы в текстовые файлы с соответствующими расширениями (.java). <br>
Компиляторы (javac) переводят исходный код в байт-код Java, хранящийся в .class файлах. <br>
Виртуальная машина Java выполняет байт-код, передавая низкоуровневые команды компьютеру.<br>
Все JVM определяются спецификацией JVM, что обеспечивает независимость программ от платформы.<br>

***Важно помнить:*** код, вводимый в JVM, не зависит от платформы, а код вывода зависит от платформы.

![Image alt](https://raw.githubusercontent.com/dianapovarnitsina/java-theory/master/theory/img/cycle_JVM_programm.png)


### Наследование

Чтобы создать новый объект в Java на основании других объектов – можно применять принципы:
- наследование (используется ключевое слово `extends`)
- ассоциация (агрегация/композиция)
  Чаще всего в проекте используется одновременно и наследование и ассоциация.

***Наследование*** - позволяет не писать заново весь код, а использовать уже готовые объекты для создания новых.

`Левый класс / дочерний (child)` – которые наследуется.
`Правый класс / родительский (parent)` – от которого наследуемся.

- Наследоваться можно только от одного родителя. <br>
- Дочерние классы обязательно наследуют все возможности родительских классов из цепочки <br>
- Дочерний класс может расширять свой функционал (добавлять новые переменные, методы и пр.) <br>
- Дочерний класс может переопределять родительские возможности (изменять в себе поведение родителей). Для этого нужно указать аннотацию @Override перед методом<br>
- Родительские классы “не видят” все новшества дочерних (т.к. они находятся выше по цепочке)
- Конструкторы НЕ НАСЛЕДУЮТСЯ в дочерние классы. НО в конструкторе дочернего класса можно вызывать через super любой родительский конструктор и “перекидывать” туда значения из дочернего, чтобы проинициализировать.

Аннотация `@Override` исключит любые ошибки уже на уровне компиляции, если вы например неверно написали название метода (или допустили другую ошибку).<br>
`@Override` переопределяет (“затирает”) метод не только первого родит. класса, но и все вышестоящие реализации, если они были.

Возле переопределенных методов показываются спец. иконки со стрелкой вниз, нажав на которые можно увидеть все переопределения данного метода в дочерних классах.
![Image alt](https://raw.githubusercontent.com/dianapovarnitsina/java-theory/master/theory/img/Override.png)


`super` — используется для обращения к базовому классу, а `this` к текущему.<br>

- super для метода (super.methodName()) – ищет вверх по цепочке родителей и вызывает первый встреченный @Override метод (или вызывает самый базовый, если не найдет).<br>
- super для конструктора (super() ) – ДОЛЖЕН вызывать конструктор только первого верхнего родительского класса – в этом отличие от super метода.<br>

Каждый вышестоящий класс может перекидывать значения в super конструкторы еще выше, пока они не дойдут до того места, где эти свойства объявлены.

***Правила:***
- super конструктор может быть вызван только из дочернего конструктора
- super конструктор можно вызывать только один раз из дочернего конструктора
- вызов super конструктора должен следовать первой строкой в дочернем конструкторе
- super методы можно вызывать как из дочерних методов, так из дочерних конструкторов
- super методы можно вызывать в любой строке, любое количество раз (нет ограничений)
- Из дочернего метода вы не можете вызвать super конструктор

```java
public class Class {

    private int number;
    private String str;
    
    public Class(int number, String str) {
        this.number = number;
        this.str = str;
    }
}


public class Class2 extends Class{
    
    private boolean bol;

    //Без параметров
    public Class2() {
    }
    
    //Параметры только для своих свойств (присвоение через this)
    public Class2(boolean bol) {
        this.bol = bol;
    }
    
    //Параметры только для родительских свойств (присвоение через super)
    public Class2(int number, String str) {
        super(number, str);
    }
    
    //Смешанные параметры – и для своих свойств и для родительских (присвоение и через this и через super)
    public Class2(int number, String str, boolean bol) {
        super(number, str);
        this.bol = bol;
       System.out.println();
    }
}
```

***Связь конструкторов в наследовании*** <br>
Каждый дочерний конструктор должен обязательно быть связан хотя бы с одним из конструкторов первого родительского класса.
Таким образом компилятор должен провести связь по каждому конструктору вверх по цепочке.
`Если мы сами не вызываем super конструктор, то компилятор автоматически пытается вызвать родительский конструктор без параметров с помощью super().`

***Порядок вызова конструкторов:***<br>
При наследовании: сначала вызывается самый верхний конструктор (базового класса) и далее вызовы “идут” вниз по цепочке по дочерним. <br>
Это важно понимать, если у вас выполняется доп. функционал в конструкторах (что лучше стараться не делать, если ест возможность – в конструкторах нежелателен никакой лишний код, кроме присвоения значений).


***Отношения между классами***
1) IS-A: <br>
   (наследник) IS-A (родитель)? => (наследник) является (родитель)? => (Лада) является (Машина)? <br>
   Дочерний объект обязательно должен утвердительно отвечать на вопрос “является?” по отношению к родителю.
2) HAS-A (отношения основаны на использовании): <br>
   *`Ассоциация` - это способ связи между объектами, когда один объект как то связан с другим. <br>
   `Агрегация` и `композиция` являются частными случаями ассоциации.
    - `Агрегация` - это отношение когда один объект является частью другого.
      Мягкий вариант, когда внутренний объект может становиться частью любого другого объекта (студент – кабинет) и
      жестко не связан с ними (студент может ходит по разным кабинетам) – в этом случае про внутренний объект говорят слово связан с внешним объектом.
    - `Композиция` - еще более тесная связь, когда объект не только является частью другого объекта, но и вообще не может принадлежать другому объекту.
      Более жесткий вариант – внутренний объект не может существовать без внешнего (человек – сердце) – в этом случае про внутренний объект говорят
      включен во внешний объект (сердце не может само по себе работать). Еще говорят “объект” является частью другого объекта.

```java
// Агрегация:
// Объект класса Halter создается извне Horse и передается в конструктор для установления связи. 
// Если объект класса Horse будет удален, объект класса Halter может и дальше использоваться, если, конечно, на него останется ссылка
public class Horse {
    private Halter halter;

    public Horse(Halter halter) {
        this.halter = halter;
    }
}
```

```java
// Композиция:
// Объект класса Halter создается в конструкторе, что означает более тесную связь между объектами. 
// Объект класса Halter не может существовать без создавшего его объекта Horse.
public class Horse {
    private Halter halter;

    public Horse() {
        this.halter = new Halter();
    }
}
```

Во многих книгах почему-то все называют одним словом – композиция (без уточнений связей).
Но можно использовать слова: связан (агрегация) и включен (композиция).

Внешний объект (еще называют “контейнер”) – может включать в себя любые другие внутренние объекты в любом количестве.
Объекты могут связаны друг с другом как матрешки – один в другом. Один объект может быть для кого контейнером и сам являться частью другого контейнера.


***Как выбрать что использовать*** <br>
Если 2 объекта логичней связать способом “содержит” – значит можно применять ассоциацию (композицию или агрегацию). <br>
Если 2 объекта логичней связать способом “является” – значит можно применять наследование.<br>
Чаще всего в проектах применяется смешанный подход: и ассоциация и наследование.

