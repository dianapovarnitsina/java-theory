### Оглавление

# OOP
+ [Парадигмы](#Парадигмы)
+ [Компиляция и запуск](#Компиляция-и-запуск)
+ [Наследование](#Наследование)
+ [Абстракция](#Абстракция)
+ [Полиморфизм](#Полиморфизм)
+ [Инкапсуляция](#Инкапсуляция)
+ [SOLID](#SOLID)
+ [GRASP](#GRASP)

### Парадигмы

Различные подходы к созданию программ называются парадигмами.<br>
Есть 2 основные парадигмы программирования:
- императивная
- декларативная.

`Императивная парадигма` фокусируется на достижении результата с помощью пошаговых инструкций, которые последовательно изменяют данные.
Императивная парадигма включает:
- парадигма процедурного программирования: основана на концепции вызовов процедур, в которых операторы структурированы в процедуры (C, Java, C++, ColdFusion, Pascal)
- объектно-ориентированное программирование (Ruby, Java, C++, Python, Simula (первый язык ООП), Smalltalk, Visual Basic .NET, Objective-C.)
- подход к параллельной обработке: достигается за счет совместного использования или распараллеливания инструкций между несколькими процессорами (NESL (один из старейших) и C/C++ (также поддерживается благодаря некоторым библиотечным функциям))

`Декларативная парадигма` фокусируется на задаче и пытается получить ожидаемый результат.
Декларативная парадигма включает в себя:
- логику (логическое программирование): основанная на математической логике — программы в ней задаются в форме логических утверждений и правил вывода (Пролог, Программирование наборов ответов (ASP) и Datalog)
- функциональность (функциональное программирование) - это парадигма программирования, в которой процесс вычислений интерпретируется как вычисление значений функций. Функция в этом случае аналогична математической. То есть функция, в которой вход — массив, который не изменяется, а выход — новый массив с новыми данными. Это отличает математическую функцию от функции в процедурном программировании, где функция представляет собой последовательность действий, изменяющих исходные данные (JavaScript, Haskell, Scala, Erlang, Lisp, ML, Clojure, OCaml, Common Lisp и F#)
- парадигму базы данных (парадигма програм-я баз данных) методология программирования основана на работе с данными


**Java реализует:**
- парадигму процедурного программирования
- ооп

![Image alt](https://raw.githubusercontent.com/dianapovarnitsina/java-theory/master/theory/img/paradigms.png)

[к оглавлению](#oop)



### Компиляция и запуск

Разработчики пишут исходный код программы в текстовые файлы с соответствующими расширениями (.java). <br>
Компиляторы (javac) переводят исходный код в байт-код Java, хранящийся в .class файлах. <br>
Виртуальная машина Java выполняет байт-код, передавая низкоуровневые команды компьютеру.<br>
Все JVM определяются спецификацией JVM, что обеспечивает независимость программ от платформы.<br>

***Важно помнить:*** код, вводимый в JVM, не зависит от платформы, а код вывода зависит от платформы.

![Image alt](https://raw.githubusercontent.com/dianapovarnitsina/java-theory/master/theory/img/cycle_JVM_programm.png)

[к оглавлению](#oop)



### Наследование

Чтобы создать новый объект в Java на основании других объектов – можно применять принципы:
- наследование (используется ключевое слово `extends`)
- ассоциация (агрегация/композиция)
  Чаще всего в проекте используется одновременно и наследование и ассоциация.

***Наследование*** - позволяет не писать заново весь код, а использовать уже готовые объекты для создания новых.

`Левый класс / дочерний (child)` – которые наследуется.
`Правый класс / родительский (parent)` – от которого наследуемся.

- Наследоваться можно только от одного родителя. <br>
- Дочерние классы обязательно наследуют все возможности родительских классов из цепочки <br>
- Дочерний класс может расширять свой функционал (добавлять новые переменные, методы и пр.) <br>
- Дочерний класс может переопределять родительские возможности (изменять в себе поведение родителей). Для этого нужно указать аннотацию @Override перед методом<br>
- Родительские классы “не видят” все новшества дочерних (т.к. они находятся выше по цепочке)
- Конструкторы НЕ НАСЛЕДУЮТСЯ в дочерние классы. НО в конструкторе дочернего класса можно вызывать через super любой родительский конструктор и “перекидывать” туда значения из дочернего, чтобы проинициализировать.

Аннотация `@Override` исключит любые ошибки уже на уровне компиляции, если вы например неверно написали название метода (или допустили другую ошибку).<br>
`@Override` переопределяет (“затирает”) метод не только первого родит. класса, но и все вышестоящие реализации, если они были.

Возле переопределенных методов показываются спец. иконки со стрелкой вниз, нажав на которые можно увидеть все переопределения данного метода в дочерних классах.
![Image alt](https://raw.githubusercontent.com/dianapovarnitsina/java-theory/master/theory/img/Override.png)


`super` — используется для обращения к базовому классу, а `this` к текущему.<br>

- super для метода (super.methodName()) – ищет вверх по цепочке родителей и вызывает первый встреченный @Override метод (или вызывает самый базовый, если не найдет).<br>
- super для конструктора (super() ) – ДОЛЖЕН вызывать конструктор только первого верхнего родительского класса – в этом отличие от super метода.<br>

Каждый вышестоящий класс может перекидывать значения в super конструкторы еще выше, пока они не дойдут до того места, где эти свойства объявлены.

***Правила:***
- super конструктор может быть вызван только из дочернего конструктора
- super конструктор можно вызывать только один раз из дочернего конструктора
- вызов super конструктора должен следовать первой строкой в дочернем конструкторе
- super методы можно вызывать как из дочерних методов, так из дочерних конструкторов
- super методы можно вызывать в любой строке, любое количество раз (нет ограничений)
- Из дочернего метода вы не можете вызвать super конструктор

```java
public class Class {

    private int number;
    private String str;
    
    public Class(int number, String str) {
        this.number = number;
        this.str = str;
    }
}


public class Class2 extends Class{
    
    private boolean bol;

    //Без параметров
    public Class2() {
    }
    
    //Параметры только для своих свойств (присвоение через this)
    public Class2(boolean bol) {
        this.bol = bol;
    }
    
    //Параметры только для родительских свойств (присвоение через super)
    public Class2(int number, String str) {
        super(number, str);
    }
    
    //Смешанные параметры – и для своих свойств и для родительских (присвоение и через this и через super)
    public Class2(int number, String str, boolean bol) {
        super(number, str);
        this.bol = bol;
       System.out.println();
    }
}
```

***Связь конструкторов в наследовании*** <br>
Каждый дочерний конструктор должен обязательно быть связан хотя бы с одним из конструкторов первого родительского класса.
Таким образом компилятор должен провести связь по каждому конструктору вверх по цепочке.
`Если мы сами не вызываем super конструктор, то компилятор автоматически пытается вызвать родительский конструктор без параметров с помощью super().`

***Порядок вызова конструкторов:***<br>
При наследовании: сначала вызывается самый верхний конструктор (базового класса) и далее вызовы “идут” вниз по цепочке по дочерним. <br>
Это важно понимать, если у вас выполняется доп. функционал в конструкторах (что лучше стараться не делать, если ест возможность – в конструкторах нежелателен никакой лишний код, кроме присвоения значений).


***Отношения между классами***
1) IS-A: <br>
   (наследник) IS-A (родитель)? => (наследник) является (родитель)? => (Лада) является (Машина)? <br>
   Дочерний объект обязательно должен утвердительно отвечать на вопрос “является?” по отношению к родителю.
2) HAS-A (отношения основаны на использовании): <br>
   *`Ассоциация` - это способ связи между объектами, когда один объект как то связан с другим. <br>
   `Агрегация` и `композиция` являются частными случаями ассоциации.
    - `Агрегация` - это отношение когда один объект является частью другого.
      Мягкий вариант, когда внутренний объект может становиться частью любого другого объекта (студент – кабинет) и
      жестко не связан с ними (студент может ходит по разным кабинетам) – в этом случае про внутренний объект говорят слово связан с внешним объектом.
    - `Композиция` - еще более тесная связь, когда объект не только является частью другого объекта, но и вообще не может принадлежать другому объекту.
      Более жесткий вариант – внутренний объект не может существовать без внешнего (человек – сердце) – в этом случае про внутренний объект говорят
      включен во внешний объект (сердце не может само по себе работать). Еще говорят “объект” является частью другого объекта.

```java
// Агрегация:
// Объект класса Halter создается извне Horse и передается в конструктор для установления связи. 
// Если объект класса Horse будет удален, объект класса Halter может и дальше использоваться, если, конечно, на него останется ссылка
public class Horse {
    private Halter halter;

    public Horse(Halter halter) {
        this.halter = halter;
    }
}
```

```java
// Композиция:
// Объект класса Halter создается в конструкторе, что означает более тесную связь между объектами. 
// Объект класса Halter не может существовать без создавшего его объекта Horse.
public class Horse {
    private Halter halter;

    public Horse() {
        this.halter = new Halter();
    }
}
```

Во многих книгах почему-то все называют одним словом – композиция (без уточнений связей).
Но можно использовать слова: связан (агрегация) и включен (композиция).

Внешний объект (еще называют “контейнер”) – может включать в себя любые другие внутренние объекты в любом количестве.
Объекты могут связаны друг с другом как матрешки – один в другом. Один объект может быть для кого контейнером и сам являться частью другого контейнера.


***Как выбрать что использовать*** <br>
Если 2 объекта логичней связать способом “содержит” – значит можно применять ассоциацию (композицию или агрегацию). <br>
Если 2 объекта логичней связать способом “является” – значит можно применять наследование.<br>
Чаще всего в проектах применяется смешанный подход: и ассоциация и наследование.

[к оглавлению](#oop)



### Абстракция

`Абстракция` – это описание поведения всех нужных объектов (по другому можно назвать: контракт, обязанности, стандарты, схема).

У каждого объекта – своя абстракция (абстрактный план как он должен работать, контракт).

Проф. подход – сначала создаем абстракцию (интерфейсы и абстрактные классы) – потом реализацию (конкретные классы)<br>

`Набор интерфейсов в проекте` – это абстрактный уровень приложения, который всегда нужно создавать <br>
`Интерфейс` – это “фантом” (схема) класса без реализации, из которого затем появляются реальные объекты <br>

Интерфейс по возможности должен включать в себя ссылки на другие интерфейсы, а не конкретные классы<br>
Интерфейс может расширять другой интерфейс по необходимости<br>
`@Override` также используется при реализации методов интерфейса<br>
Класс обязан реализовать все методы интерфейса<br>
Нельзя создать экземпляр интерфейса<br>
Класс может реализовывать любое количество интерфейсов (в отличие от наследования) через запятую<br>
Вы можете описывать в интерфейсе не только методы-действия, но и методы-свойства<br>
default методы в интерфейсе используются как заглушки (у них сильно ограничен функционал)<br>
`Абстрактный класс` – это промежуточный вариант между интерфейсом и конкретным классом<br>
Основное назначение абстрактного класса – реализовать часть интерфейса (“разгрузить” конкретные классы), вынести общий код, избежать дублирования кода в дочерних классах<br>
Лучше всю абстракцию полностью выносить только в интерфейсы (легче изучать, сопровождать и писать код)<br>
Абстрактные методы в абстрактном классе желательно не использовать<br>
Абстрактный класс также может иметь конструкторы (в интерфейсе – нет конструкторов, как и свойств)<br>
Нельзя создать экземпляр абстрактного класса

`Интерфейс` – только поведение

`Абстрактный класс` – поведение и/или реализация

`Конкретный класс` – только реализация.

[к оглавлению](#oop)



### Полиморфизм

Полиморфизм – это возможность создать единый код, который сможет обрабатывать объекты разных типов<br>
Тип переменной (ссылки на объект) должен быть как можно более общий (в идеале – интерфейс)<br>
Доступные для вызова элементы (методы, переменные) зависят от типа переменой-ссылки, а не от фактического объекта<br>
Приведение – изменение типа переменной, чтобы вызывать все нужные элементы, без ограничений видимости<br>

[к оглавлению](#oop)



### SOLID
SOLID – это принципы ООП (по первым буквам названий) для любого приложения

Принципы SOLID – какие пункты нужно учитывать при создании любого ООП проекта. С этими пунктами всегда нужно сверяться по ходу разработки, чтобы они вошли в привычку.

SOLID помогает писать расширяемый, универсальный код.

```text
S: Single Responsibility Principle (Принцип единственной ответственности).
O: Open-Closed Principle (Принцип открытости-закрытости).
L: Liskov Substitution Principle (Принцип подстановки (заменяемости) Барбары Лисков).
I: Interface Segregation Principle (Принцип разделения интерфейса).
D: Dependency Inversion Principle (Принцип инверсии зависимостей).
```

>S: Single Responsibility Principle или SRP (Принцип единственной ответственности):

“Каждый должен заниматься своим делом” <br>
В коде каждый класс (объект) должен выполнять только свою работу. Если класс выполняет чужую работу – нужно делить его на неск. частей.<br>
Машина должны уметь только перевозить пассажира и не должны “лезть” в уборку дома.<br>
Каждый объект должен быть по смыслу атомарным, самодостаточным.<br>

>O: Open-Closed Principle или OCP (Принцип открытости-закрытости):

«Программные сущности (классы, модули, функции и т. п.) должны быть открыты для расширения, но закрыты для изменения» <br>
Вы не должны модифицировать старый класс, чтобы создать новый функционал (новую реализацию).<br>
Вместо этого нужно создавать наследников – каждый со своей реализацией (тогда базовый класс останется без изменений)<br>

>L: Liskov Substitution Principle или LSP (Принцип подстановки (заменяемости) Барбары Лисков):

Впервые этот принцип был упомянут Барбарой Лисков в 1987 году на научной конференции, посвященной объектно-ориентированному программированию.
Можно было назвать просто “принцип подстановки”

Ключевое слово здесь – “подстановка” или “заменяемость”<br>
“Функции, которые используют базовый тип, должны иметь возможность использовать подтипы базового типа не зная об этом”<br>
Поэтому функция должна быть универсальной, чтобы не приходилось ее постоянно переписывать.<br>
Вы не должны проверять тип объекта (instance of), чтобы реализовать нужный функционал.<br>
Принцип LSP чем-то похож на OCP, но в LSP речь идет именно об “универсальной функции”, которая должна уметь работать с любыми существующими или будущими типами, которые в будущем могут быть созданы<br>
Основное решение – использование полиморфизма, когда в зависимости от предоставленного объекта будет подставляться нужная реализация.<br>
Именно поэтому в название присутствует слово “подстановка“.


>I: Interface Segregation Principle или ISP (Принцип разделения интерфейса):

“Нужно создавать такие интерфейсы, в которых описан только необходимый минимум реализаций методов”<br>
Основная мысль – максимально делить (дробить) интерфейсы, но не слишком мелко.<br>
Вместо того чтобы класс реализовывал один большой интерфейс, лучше пусть реализовывает несколько мелких.<br>
НЕ следует создавать избыточные интерфейсы, которые будут обязывать классы реализовывать то, что им не нужно (не свойственно их поведению). Лучше разбить такой интерфейс на несколько.<br>
Каждый интерфейс занимается только своим делом. Не нужно создавать универсальный интерфейс, который умеет все, или лезть в чужие дела.<br>
Эта мысль перекликается с первым принципом SOLID – Single Responsibility Principle (Принцип единственной ответственности)<br>


>D: Dependency Inversion Principle (Принцип инверсии зависимостей):

- Объекты верхних уровней не должны зависеть от нижних уровней. Оба типа объектов должны зависеть от абстракций – нужно стараться не перемешивать между собой абстрактный уровень и уровень реализации.
- Абстракции не должны зависеть от деталей. Детали должны зависеть от абстракций – создаем интерфейсы, абстрактные классы, и обычные классы – идем от общего к частному

Например, в интерфейсе нужно стараться использовать (если есть возможность) типы других интерфейсов, а не конкретные типы (абстрактное ссылается на абстрактное).

[к оглавлению](#oop)



### GRASP

GRASP или еще пишут G.R.A.S.P. – означает general responsibility assignment software patterns – общие шаблоны распределения ответственностей – или по-другому как правильно разделить ООП проект на объекты, обязанности, связи – чтобы не было “спагетти кода” (запутанного)

Шаблон (паттерн) проектирования – типовой (оптимальный) способ решения часто встречающихся проблем при проектировании программ.

GoF – это паттерны для конкретных ситуаций, а 
GRASP – это больше подходы (принципы), которые нужно соблюдать во всех приложениях ООП

GRASP – это список шаблонов, которые вы должны стараться применять в своих проектах

Хотя тут более уместно использовать слово не шаблон, а принципы (как в SOLID), потому что GRASP – это больше про подход к написанию правильного кода, а не решение каких-то конкретных задач (как в (паттернах GoF).

***Паттерны могут быть разных типов:***

- программный (структура кода) – адаптируете для своего проекта
- архитектурный (структура проекта) – как выстроить все компоненты проекта, как они должны взаимодействовать
- UI – user interface (внешний вид) – для удобного использований кнопок, окон и пр. (UX – user experience)
и многие другие

Каждый из типов внутри себя еще делится на многие типы.

Список GRASP состоит из 5 основных и 4 дополнительных шаблонов.

***Основные шаблоны:***
- Information Expert– обработка данных объекта
```text
“Информация должна обрабатываться там, где она содержится”

Пересекается с принципов SOLID – single responsibility principle – каждый должен заниматься своим делом и не лезть в чужие дела.

Нужно правильно делить проект на объекты (классы), чтобы обработка данных велась именно в том месте, где это логично и где содержится вся нужная информация.

Очень часто этот принцип нарушается, хотя многим он кажется элементарным.

Expert владеет всей необходимой информацией и логично, что именно он должен выполнять операции над ней.
```

- Creator – вложенность объектов

```text
За что отвечает:

Кто кого должен создавать (содержать)
Какой объект должен быть вложен в другой
Как объекты должны ссылаться друг на друга”
Объект должен находиться (включен) именно в том объекте, которому он нужен в первую очередь.
```
- Controller – обработка действий в UI

```text
Сontroller – это промежуточный слой между “логикой” приложения и действиями пользователя (нажимает кнопку, выбирает меню и пр.)
Любое визуальное приложение нужно поделить на уровни (слои), чтобы каждый уровень занимался только своим делом (SRP из SOLID).
Часто в таких приложениях используется паттерн MVC – Model-View-Controller

Model – это логика

View – внешний вид, окна, кнопки

Controller – обрабатывает действия пользователя

Логика напрямую не должна быть связана с UI.
Чтобы перенести логику для использования в другом UI – достаточно будет переделать контроллер.
Логика не от чего не зависит и она должна быть “сама по себе”.
Контроллер ничего не знает о том, как работает логика – он обрабатывает действия пользователя и вызывает нужные методы из логики.


```

- Low Coupling – слабое связывание

```text
“Чем меньше связей между объектами – тем лучше”
Нужно использовать минимально необходимое кол-во ссылок из одного объекта на другой , чтобы было достаточно для реализации функционала.
Чем меньше объект знает о других объектах – тем лучше.
Чем меньше “жестких” связей между объектами – тем лучше.
```

- High Cohesion – высокая связанность

```text
Каждый объект должен “связывать” внутри себя именно свою бизнес логику (похож на принцип single responsibility из SOLID) и не лезть в чужие дела.
Многие думают, что это противоположность Low coupling (LP) – слабое связывание.
Если реализовать LP таким образом, чтобы весь функционал проекта будет в одном классе – то это не нарушит принципа LP, т.к. связей теперь вообще нет (в проекте создается только один объект).
Но это нарушит принцип High cohession (HC) – т.е. один объект содержит несколько логик.

Поэтому HC и LP всегда нужно стараться использовать вместе, чтобы уравновесить друг друга и не дать:

- одному объекту забрать себе ненужный функционал
- в то же время – стараться иметь как можно меньше жестких связей с другими объектами

Т.е. нужно находить баланс между логикой объекта и его связями.
```


***Дополнительные шаблоны:***

- Pure Fabrication – искусственные объекты

```text
Не нужно бояться создавать вспомогательные объекты узкой направленности, если это поможет сохранить LC и HC.
Многие пытаются создавать в проекте только те объекты, которые похожи на реальные объекты из жизни, чтобы при чтении кода все было логично и понятно.
Но это не всегда будет получаться, т.к. часто создаются объекты, которые являются утилитами или выполняют работу, у которой нет аналогов из жизни.
Например, во всех приложениях, где есть БД – создается отдельный слой, который отвечает только за сохранения данных в БД и выполнение запросов.
Это специальные системные объекты, которые не входят в “предметную область” (Order, Shop и пр.), но без них приложение работать не будет.
И тогда самим объектам (Order, Shop и пр.) не нужно будет внутри себя реализовать методы для запросов в БД – они останутся “чистыми” и будут заниматься только своей логиков. Это позволит соблюсти принципы LC и HC
```

- Indirection – ссылки на интерфейсы, а не объекты

```text
“Везде в коде, где это возможно – нужно стараться использовать ссылки на интерфейсы, а не конкретные типы”
Тем самым это поможет соблюдать LC, HC, PF, использовать полиморфизм, создавать универсальный код и т.д.
Похож на принцип SOLID – Dependency Inversion, где требуется тоже максимально использовать интерфейсы, вместо обычных типов.
```

- Polymorphism – универсальный код

```text
“Распределение обязанностей между классами с использованием полиморфных операций”
Полиморфизм выделили как отдельный пункт GRASP – хотя это инструмент ООП, который помогает создавать универсальный код.
Пересекается или используется почти во всех принципах SOLID и GRASP – потому что является инструментов ООП.

```

- Protected Variations

```text
Protected Variations (PV) – это скорее рекомендация, чем шаблон.

PV собирает вместе все принципы GRASP и SOLID для правильного создания объектов, модулей и всей системы.

Чтобы изменение одних объектов/систем/модулей как можно меньше влияли на другие.

По сути – просто всегда на каждом проекте идите по списку всех пройденных пунктов SOLID и GRASP и пытайтесь “свериться” со своим кодом – все ли вы делаете верно.

ВСЕГДА задавайтесь вопросом при создании объектов: будет ли он себя нормально вести если:

добавится новый объект такого же интерфейса
подключим другую БД
заменим объект на другой того же интерфейса
добавим новое поведение (интерфейсы)
удалим из системы полностью
Всегда смотрите дальше, наперед, за горизонт – и проектируйте объектов с учетом этого.
```

[к оглавлению](#oop)

