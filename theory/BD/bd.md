# БД
```text
Что такое типы СУБД (реляционные, нереляционные)
Что такое транзакции
Базы данных и синтаксис

Умения:
Подключиться к базе данных
Написать на Select * from table1 join table2
Join-ить таблицы, обновлять данные, делать подселекты, группировки и сортировокии
Написать запросы и агрегатные функций
```

### Оглавление

+ [Что такое базы данных? На какие типы они делятся?](#Что-такое-базы-данных?-На-какие-типы-они-делятся?)
+ [Команды SQL](#Команды SQL)
+ [Синтаксис SQL](#Синтаксис SQL)
+ [Типы данных](#Типы данных)
+ [Операторы](#Операторы)
+ [Ограничения](#Ограничения)
+ [Агрегатные функции SQL](#Агрегатные функции SQL)
+ [Что такое нормализация? Нормализованная форма? Сколько форм нормализации существует? Назовите первые три.](#Что-такое-нормализация?-Нормализованная-форма?-Сколько-форм-нормализации-существует?-Назовите-первые-три.)
+ [Денормализация](#Денормализация)
+ [Индексы](#Индексы)
+ [Кластеризованным и некластеризованный индекс](#В-чем-разница-между-кластеризованным-и-некластеризованным-индексами-в-SQL?)
+ [Что такое покрывающий индекс? Уникальный индекс?](#Что-такое-покрывающий-индекс?-Уникальный-индекс?)
+ [Что такое первичный ключ](#Что-такое-первичный-ключ)
+ [Что такое внешний ключ?](#Что-такое-внешний-ключ?)
+ [Типы соединений между таблицами (Join)](#Типы-соединений-между-таблицами(Join))
+ [Что такое свойство ACID в базе данных?](#Что-такое-свойство-ACID-в-базе-данных?)
+ [Уровни изолированности транзакций](#Уровни-изолированности-транзакций)
+ [Что такое SQL-инъекция?](#Что-такое-SQL-инъекция?)
+ [Что такое хранимые процедуры? Хранимые функции? Триггер?](#Что-такое-хранимые-процедуры?-Хранимые-функции?-Триггер?)
+ [Перечисление существующих БД](#Перечисление-существующих-БД)


### Что такое базы данных? На какие типы они делятся?

`База данных` — это  структурированное хранилище данных.

`СУБД` — это система, позволяющая создавать базы данных и манипулировать сведениями из них.
СУБД гарантирует сохранность, целостность, безопасность хранения данных и позволяет выдавать доступ к администрированию БД.

`Таблица` — это самая распространенная и простая форма хранения данных в РБД. 

`Поле` — это колонка таблицы, предназначенная для хранения определенной информации о каждой записи в таблице.

`Запись или строка (record/row)` — это любое единичное вхождение (entry), существующее в таблице.

`Транзакции` — это набор операторов SQL, которые необходимо выполнить один за другим без сбоев. В случае сбоя хотя бы одной операции транзакция считается неудачной.


***Типы БД***

`Реляционная база данных` — это набор данных с предопределенными связями между ними. 
Данные хранятся в виде набора таблиц, состоящих из столбцов и строк. 
В таблицах хранится информация об объектах, представленных в базе данных. 
В каждом столбце таблицы хранится определенный тип данных, в каждой ячейке — значение атрибута.

`Нереляционные системы (NoSQL)` — системы, созданные для определенных моделей данных, обладающие гибкими схемами. 
Иначе говоря, это БД, которые хранят данные не в виде табличных схем, строк и столбцов, а в иных форматах.


### Команды SQL

Стандартными командами для взаимодействия с РБД являются `CREATE, SELECT, INSERT, UPDATE, DELETE и DROP`

Эти команды могут быть классифицированы следующим образом:

1) DDL — язык определения данных (Data Definition Language):
```text
CREATE	Создает новую таблицу, представление таблицы или другой объект в БД
ALTER	Модифицирует существующий в БД объект, такой как таблица
DROP	Удаляет существующую таблицу, представление таблицы или другой объект в БД
```
2) DML — язык изменения данных (Data Manipulation Language):
```text
SELECT	Извлекает записи из одной или нескольких таблиц
INSERT	Создает записи
UPDATE	Модифицирует записи
DELETE	Удаляет записи

```
3) DCL — язык управления данными (Data Control Language):
```text
GRANT	Наделяет пользователя правами
REVOKE	Отменяет права пользователя
```

Обратите внимание: использование верхнего регистра в названиях команд SQL — это всего лишь соглашение, большинство СУБД нечувствительны к регистру.
Тем не менее, форма записи инструкций, когда названия команд пишутся большими буквами, а названия таблиц, колонок и др. — маленькими,
позволяет быстро определять назначение производимой с данными операции.


### Синтаксис SQL

`Синтаксис` — это уникальный набор правил и рекомендаций. 

Все инструкции SQL должны начинаться с ключевого слова, такого как SELECT, INSERT, UPDATE, DELETE, ALTER, DROP, CREATE, USE, SHOW и т.п. 
и заканчиваться точкой с запятой (;) (точка с запятой не входит в синтаксис SQL, но ее наличия, как правило, требуют консольные клиенты СУБД для обозначения окончания ввода команды). 
SQL не чувствителен к регистру, т.е. SELECT, select и SeLeCt являются идентичными инструкицями. 
Исключением из этого правила является MySQL, где учитывается регистр в названии таблицы.

Примеры синтаксиса:

```postgresql
-- выборка
SELECT col1, col2, ...colN
FROM tableName;

SELECT DISTINCT col1, col2, ...colN
FROM tableName;

SELECT col1, col2, ...colN
FROM tableName
WHERE condition;

SELECT col1, col2, ...colN
FROM tableName
WHERE condition1 AND|OR condition2;

SELECT col2, col2, ...colN
FROM tableName
WHERE colName IN (val1, val2, ...valN);

SELECT col1, col2, ...colN
FROM tableName
WHERE colName BETWEEN val1 AND val2;

SELECT col1, col2, ...colN
FROM tableName
WHERE colName LIKE pattern;

SELECT col1, col2, ...colN
FROM tableName
WHERE condition
ORDER BY colName [ASC|DESC];

SELECT SUM(colName)
FROM tableName
WHERE condition
GROUP BY colName;

SELECT COUNT(colName)
FROM tableName
WHERE condition;

SELECT SUM(colName)
FROM tableName
WHERE condition
GROUP BY colName
HAVING (function condition);

-- создание таблицы
CREATE TABLE tableName (
  col1 datatype,
  col2 datatype,
  ...
  colN datatype,
  PRIMARY KEY (одна или более колонка)
);

-- удаление таблицы
DROP TABLE tableName;

-- создание индекса
CREATE UNIQUE INDEX indexName
ON tableName (col1, col2, ...colN);

-- удаление индекса
ALTER TABLE tableName
DROP INDEX indexName;

-- получение описания структуры таблицы
DESC tableName;

-- очистка таблицы
TRUNCATE TABLE tableName;

-- добавление/удаление/модификация колонок
ALTER TABLE tableName ADD|DROP|MODIFY colName [datatype];

-- переименование таблицы
ALTER TABLE tableName RENAME TO newTableName;

-- вставка значений
INSERT INTO tableName (col1, col2, ...colN)
VALUES (val1, val2, ...valN)

-- обновление записей
UPDATE tableName
SET col1 = val1, col2 = val2, ...colN = valN
[WHERE condition];

-- удаление записей
DELETE FROM tableName
WHERE condition;

-- создание БД
CREATE DATABASE [IF NOT EXISTS] dbName;

-- удаление БД
DROP DATABASE [IF EXISTS] dbName;

-- выбор БД
USE dbName;

-- завершения транзакции
COMMIT;

-- отмена изменений
ROLLBACK;
```

### Типы данных

Каждая колонка, переменная и выражение в SQL имеют определенный тип данных (data type). Основные категории типов данных:


***Точные числовые:***

Тип данных	|От	                        |До
------------|---------------------------|----------------------------
bigint	    |-9,223,372,036,854,775,808	|+9,223,372,036,854,775,807
int	        |-2,147,483,648	            |2,147,483,647
smallint	|-32,768	                |32,767
tinyint	    |0	                        |255
bit	        |0	                        |1
decimal	    |-10^38 +1	                |10^38 -1
numeric	    |-10^38 +1	                |10^38 -1
money	    |-922,337,203,685,477.5808	|+922,337,203,685,477.5807
smallmoney	|-214,748.3648	            |+214,748.3647


***Приблизительные числовые***

Тип данных	|От	                        |До
------------|---------------------------|--------------
float	    |-1.79E + 308	            | 1.79E + 308
real	    |-3.40E + 38	            | 3.40E + 38

***Дата и время***

Тип данных	    |От	                        |До
----------------|---------------------------|--------------
datetime	    |Jan 1, 1753	            |Dec 31, 9999
smalldatetime	|Jan 1, 1900	            |Jun 6, 2079
date	        |Дата сохраняется в виде June 30, 1991
time	        |Время сохраняется в виде 12:30 P.M.

***Строковые символьные***

Тип данных	    |От	                        
----------------|---------------------------
char	        |Строка длиной до 8,000 символов (не-юникод символы, фиксированной длины)            
varchar	        |Строка длиной до 8,000 символов (не-юникод символы, переменной длины)	            
text	        |Не-юникод данные переменной длины, длиной до 2,147,483,647 символов

***Строковые символьные (юникод)***

Тип данных	    |От
----------------|---------------------------
nchar	        |Строка длиной до 4,000 символов (юникод символы, фиксированной длины)
nvarchar	    |Строка длиной до 4,000 символов (юникод символы, переменной длины)
ntext	        |Юникод данные переменной длины, длиной до 1,073,741,823 символов

***Бинарные***

Тип данных	    |От
----------------|---------------------------
binary	        |Данные размером до 8,000 байт (фиксированной длины)
varbinary	    |Данные размером до 8,000 байт (переменной длины)
image	        |Данные размером до 2,147,483,647 байт (переменной длины)


***Смешанные***

Тип данных	    |От
----------------|---------------------------
timestamp	    |Уникальные числа, обновляющиеся при каждом изменении строки
uniqueidentifier|Глобально-уникальный идентификатор (GUID)
cursor	        |Объект курсора
table	        |Промежуточный результат, предназначенный для дальнейшей обработки

### Операторы

Оператор (operators) — это ключевое слово или символ, которые, в основном, используются в инструкциях WHERE для выполнения каких-либо операций. 
Они используются как для определения условий, так и для объединения нескольких условий в инструкции.

В дальнейших примерах мы будем исходить из предположения, что переменная a имеет значение 10, а b — 20.

Арифметические

```text
+ (сложение)	Сложение значений	
— (вычитание)	Вычитание правого операнда из левого	0
* (умножение)	Умножение значений	
/ (деление)	Деление левого операнда на правый	
% (деление с остатком/по модулю)	Деление левого операнда на правый с остатком (возвращается остаток)
```


Операторы сравнения

```text
=	Определяет равенство значений	a = b -> false
!=	Определяет НЕравенство значений	a != b -> true
<>	Определяет НЕравенство значений	a <> b -> true
>	Значение левого операнда больше значения правого операнда?	a > b -> false
<	Значение левого операнда меньше значения правого операнда?	a < b -> true
>=	Значение левого операнда больше или равно значению правого операнда?	a >= b -> false
<=	Значение левого операнда меньше или равно значению правого операнда?	a <= b -> true
!<	Значение левого операнда НЕ меньше значения правого операнда?	a !< b -> false
!>	Значение левого операнда НЕ больше значения правого операнда?   a !> b -> true
```

Логические операторы

```text
ALL	Сравнивает все значения
AND	Объединяет условия (все условия должны совпадать)
ANY	Сравнивает одно значение с другим, если последнее совпадает с условием
BETWEEN	Проверяет вхождение значения в диапазон от минимального до максимального
EXISTS	Определяет наличие строки, соответствующей определенному критерию
IN	Выполняет поиск значения в списке значений
LIKE	Сравнивает значение с похожими с помощью операторов подстановки
NOT	Инвертирует (меняет на противоположное) смысл других логических операторов, например, NOT EXISTS, NOT IN и т.д.
OR	Комбинирует условия (одно из условий должно совпадать)
IS NULL	Определяет, является ли значение нулевым
UNIQUE	Определяет уникальность строки
```

### Ограничения

`Ограничения (constraints)` — это правила, применяемые к данным. Они используются для ограничения данных, которые могут быть записаны в таблицу. Это обеспечивает точность и достоверность данных в БД.

Ограничения могут устанавливаться как на уровне колонки, так и на уровне таблицы.

Среди наиболее распространенных ограничений можно назвать следующие:


NOT NULL — колонка не может иметь нулевое значение
DEFAULT — значение колонки по умолчанию
UNIQUE — все значения колонки должны быть уникальными
PRIMARY KEY — первичный или основной ключ, уникальный идентификатор записи в текущей таблице
FOREIGN KEY — внешний ключ, уникальный идентификатор записи в другой таблице (таблице, связанной с текущей)
CHECK — все значения в колонке должны удовлетворять определенному условию
INDEX — быстрая запись и извлечение данных

Любое ограничение может быть удалено с помощью команды ALTER TABLE и DROP CONSTRAINT + название ограничения. Некоторые реализации предоставляют сокращения для удаления ограничений и возможность отключать ограничения вместо их удаления.

### Агрегатные функции SQL

`Функция SQL` — это набор операторов SQL, которые принимают входные данные и выполняют с ними действия SQL, а затем возвращают результаты в виде выходных данных.

В SQL есть два типа функций: функции set и функции value. 
Функция, которая манипулирует строками данных в таблице и возвращает одно значение, называется функцией set (агрегатная функция). 

MIN
```postgresql
SELECT MIN(Price) AS LeastPricy
FROM Products;
```
Эта функция SQL возвращает самую низкую цену из всех продуктов в таблице Products.

MAX
```postgresql
SELECT MAX(Price) AS MostExpensive
FROM Products;
```
Эта функция SQL возвращает самую высокую цену из всех продуктов в таблице Products.

AVG
```postgresql
SELECT AVG(Price) AS AveragePrice
FROM Products;
```
Эта функция SQL возвращает среднюю цену среди всех продуктов в таблице Products.

COUNT
```postgresql
SELECT COUNT(ProductID)
FROM Products;
```
Эта команда возвращает количество продуктов в таблице Products.

SUM
```postgresql
SELECT SUM(Quantity)
FROM OrderDetails;
```
Возвращает сумму всех заказов в таблице Order Details.


Функций для работы со строками:
```text
CONCAT — объединение строк
LENGTH — возвращает количество символов в строке
TRIM — удаляет пробелы в начале и конце строки
SUBSTRING — извлекает подстроку из строки
REPLACE — заменяет подстроку в строке
LOWER — переводит символы строки в нижний регистр
UPPER — переводит символы строки в верхний регистр и т.д.
```

С числами:
```text
ROUND — округляет число
TRUNCATE — обрезает дробное число до указанного количества знаков после запятой
CEILING — возвращает наименьшее целое число, которое больше или равно текущему значению
FLOOR — возвращает наибольшее целое число, которое меньше или равно текущему значению
POWER — возводит число в указанную степень
SQRT — возвращает квадратный корень числа
RAND — генерирует случайное число с плавающей точкой в диапазоне от 0 до 1
```

C датой:
```text
CURDATE/CURRENT_DATE — возвращает текущую дату
CURTIME/CURRENT_TIME — возвращает текущее время и т.д.
```

Для разбора даты и времени
```text
DAYOFMONTH(date) — возвращает день месяца в виде числа
DAYOFWEEK(date) — возвращает день недели в виде числа
DAYOFYEAR(date) — возвращает номер дня в году
MONTH(date) — возвращает месяц
YEAR(date) — возвращает год
LAST_DAY(date) — возвращает последний день месяца в виде даты
HOUR(time) — возвращает час
MINUTE(time) — возвращает минуты
SECOND(time) — возвращает секунды и др.
```

Для манипулирования датами:
```text
DATE_ADD(date, interval) — выполняет сложение даты и определенного временного интервала
DATE_SUB(date, interval) — выполняет вычитание из даты определенного временного интервала
DATEDIFF(date1, date2) — возвращает разницу в днях между двумя датами
TO_DAYS(date) — возвращает количество дней с 0-го дня года
TIME_TO_SEC(time) — возвращает количество секунд с полуночи и др.
```

Для форматирования даты и времени используются функции DATE_FORMAT(date, format) и TIME_FORMAT(date, format), соответственно.

### Что такое нормализация? Нормализованная форма? Сколько форм нормализации существует? Назовите первые три.

`Нормализация` — это процесс организации, структуризации данных в базе, который обеспечивает большую гибкость базы данных за счет исключения избыточности и несогласованности зависимостей.

`Нормальная форма` — свойство таблицы, рассматриваемое в контексте нормализации, которое характерезует таблицу с точки зрения простоты и правильности построения структуры. 
Нормальная форма определяется как совокупность требований, которым должна удовлетворять таблица.

Всего существует шесть нормальных форм, но на практике применяются не более первых трех:

- ***Первая нормальная форма:***<br>
Все атрибуты простые (то есть атомарные и неделимые);<br>
Все данные скалярные (то есть положительные);<br>
Нет повторяющихся строк (для этого для каждой строки создается первичный ключ).<br>


- ***Вторая нормальная форма:***<br>
Соблюдены условия первой нормальной формы;<br>
Каждый неключевой атрибут ссылается на первичный ключ.<br>


- ***Третья нормальная форма:***<br>
Соблюдены условия второй нормальной группы;<br>
Неключевые поля не зависят от других неключевых полей: они могут быть связаны лишь с первичным ключом.<br>


### Денормализация

`Денормализация` — намеренное снижение или нарушение форм нормализации базы данных, 
обычно — чтобы ускорить чтение из базы за счет добавления избыточных данных. 
В общем, это процесс, обратный к нормализации.


Так происходит потому, что теория нормальных форм не всегда применима на практике.

К примеру, не атомарные значения — не всегда «зло»:иногда даже наоборот. 
В некоторых случаях необходимо дополнительное объединение при выполнении запросов, особенно при обработке большого массива информации. 
В итоге это может улучшить производительность.

Для баз данных, предназначенных для аналитики, часто выполняют денормализацию, чтобы ускорить выполнение запросов.

Например, у вас часто будет производиться выборка некоторых данных для отчетов, где неключевые колонки будут связаны между собой. 
Вы намеренно убираете третью форму нормализации и объединяете все в одной таблице для удобства выборки — чтобы не пришлось делать дополнительные запросы в другие таблицы.


### Индексы

`Индекс` — отсортированный набор значений, связанных с таблицей или представлением с конкретной колонкой, который ускоряет получение данных.

```postgresql
CREATE INDEX idx_lastname
ON Persons (LastName);
```
То есть это указатель, который помогает нам при поиске по фамилии. <br>
Если использовать эту возможность правильно, можно сильно повысить производительность при работе с большими базами данных. А можно и сильно понизить. <br>

Чтобы ускорить поиск, эти ключи хранятся в виде структуры сбалансированного дерева, по которому выполняется поиск.
Как правило индексы нужно вводить на поля, по которым наиболее часто ведется поиск. 
Задумываться о создании индекса нужно не ранее, чем когда у вас появится хотя бы 10 тысяч записей. 
В ином случае заметного результата вы не увидите, ибо преждевременная оптимизация — ЗЛО.<br>


***Как индекс может ударить по производительности системы?***<br>
При вставке новых данных или удалении старых структура сбалансированного дерева будет заново пересчитываться. 
Собственно, чем больше данных и индексов, тем больше деревьев нужно пересчитать.
Представьте ситуацию: у вас есть порядка 20 000 записей и 7 индексов на эту таблицу. 
То есть, при вставке данных нужно заново пересчитать 7 деревьев, в каждом из которых — по 20 000 записей.
Строго говоря, использовать индексы для таблиц, в которые будут часто добавляться/удаляться данные, и вовсе не рекомендуется.
Напоследок отмечу то, что индексы для столбцов, в которых часто встречается значение null, будут не так эффективны, поэтому не стоить их добавлять на такие колонки.





### В чем разница между кластеризованным и некластеризованным индексами в SQL?

***Кластеризованный:***
- Обеспечивает физический порядок по выбранному полю;
- Если у таблицы есть кластеризованный индекс, она называется кластеризованной;
- Нужно не более одного индекса на таблицу;
- В MySQL кластеризованный индекс не задается явно пользователем, так как если вы не определяете PRIMARY KEY для своей таблицы, 
MySQL находит первый индекс UNIQUE, где все ключевые столбцы — NOT NULL, и InnoDB использует его в качестве кластеризованного индекса.

***Некластеризованный:***
- В одной таблице возможно до 999 некластеризованных индексов;
- Содержит указатель на строки с реальными данными в таблице;
- Не обеспечивает физический порядок;
- Для некластеризованных индексов присутствуют отдельные таблицы с отсортированными данными, 
а именно — одна таблица для одного столбца, на котором индекс, поэтому при запросе данных, не входящих в состав данного поля, 
будет сначала выполняться запрос к полю в данной таблице, а только затем — дополнительный запрос к строке в изначальной таблице.
- Создание некластеризованного индекса:

```postgresql
CREATE INDEX index_name ON table_name(column_name)
```

### Что такое составной индекс?

`Составной индекс` — построенный с посыланием на несколько колонок одновременно. Иначе говоря, это комплексный индекс, состоящий из нескольких колонок.

Такие индексы используют, когда в одном запросе фигурирует более одной колонки.

Создание составного индекса:

```postgresql
CREATE INDEX index_name ON table_name(first_column_name, second_column_name, third_column_name)
```

Как правило, эти индексы используются, когда данные в нескольких столбцах логически взаимосвязаны.


### Что такое покрывающий индекс? Уникальный индекс?

`Покрывающий индекс` — это индекс, которого вполне достаточно для ответа на запрос без обращения к самой таблице. 
По этому индексу можно достать всю строку данных, но по факту это просто не нужно.

Благодаря тому, что не нужно ходить непосредственно в исходную таблицу, а ответить можно, используя только индекс, 
покрывающие индексы немного быстрее в использовании. При этом не стоит забывать, что чем больше колонок, 
тем более громоздким и медленным становится сам индекс. Так что злоупотреблять этим не стоит.

Пример создания уникального некластеризованного индекса:

```postgresql
CREATE UNIQUE INDEX index_name ON table_name(column_name)
```

### Что такое первичный ключ
`Первичный ключ (Primary key)` — поле в таблице для идентификации каждой строки в таблице базы данных. Это уникальный, кластеризованный индекс.
В таблице может быть только одно такое поле, и все значения должны быть уникальными.

***Как правило, первичные ключи создаются, при заведении таблицы:***

```postgresql
CREATE TABLE table_name(
column_name int PRIMARY KEY,
...
                       )
```

>К данной колонке автоматически добавится ограничение — NOT NULL.

***Также можно задать ключ и для уже созданной таблицы:***

```postgresql
ALTER TABLE table_name ADD PRIMARY KEY (column_name);
```

Если первичный ключ добавляется способом, описанным выше, то значения полей, задаваемых как первичный ключ (column_name), 
проверяется на отсутствие нулевых (также будет добавлено ограничение — NOT NULL).


### Что такое внешний ключ?

`Внешний ключ (Foreign key)` — это свойство, создаваемое для того, чтобы обеспечить связь между таблицами.

Как правило, внешний ключ устанавливается для столбцов в подчиненной таблице и указывает на один из столбцов из главной таблицы.

***Может задаваться как при создании таблицы:***

```postgresql
CREATE TABLE table_name{
column_name int,
…..
    
FOREIGN KEY(column_name) REFERENCES another_table_name(another_table_column_name) }
```


***Так и после создания таблицы:***

```postgresql
ALTER TABLE table_name
ADD FOREIGN KEY(column_name) REFERENCES another_table_name(another_table_column_name));

```

Можно задать `поведение внешнего ключа при манипуляциях с полем`, на которое он ссылается.
Манипуляции могут быть вида ON DELETE и ON UPDATE.

**Возможные варианты поведения:**

CASCADE — с этим свойством будут автоматически удалены или изменены строки из зависимой таблицы при удалении или изменении связанных строк в главной таблице;
SET NULL — при данном свойстве, когда происходит удаление или обновление связанной строки из главной таблицы, будет устанавливаться значение NULL для столбца внешнего ключа;
NO ACTION — отклоняет попытки удалить или изменить строки в главной таблице, если присутствуют связанные строки в зависимой таблице;
RESTRICT — эквивалентно NO ACTION;
SET DEFAULT — при данном свойстве, когда происходит удаление или обновление связанной строки из главной таблицы, будет устанавливаться значение по умолчанию (если оно есть) для столбца внешнего ключа.

Пример использования:

```postgresql
CREATE TABLE table_name{
column_name int,
…..
FOREIGN KEY(column_name) REFERENCES another_table_name(another_table_column_name) ON UPDATE CASCADE ON DELETE CASCADE }
```

Если не будет явно задано поведение для ON DELETE и ON UPDATE, то будет устанавливаться поведение RESTRICT.


### Типы соединений между таблицами (Join)

Связь между таблицами обеспечивается на основе общих данных (полей).

Это происходит с помощью оператора `JOIN` — операции, которая сопоставляет строки из одной таблицы со строками в другой.

Сопоставление выполняется так, чтобы столбцы обеих таблиц располагались рядом, хотя их можно получить из отдельных таблиц. 
И если у нас есть общие поля для трех таблиц, мы можем вывести их данные в виде одной общей таблицы.

Тем не менее, стоит учитывать, что чем меньше таблиц объединяется, тем быстрее будет выполняться запрос.

Виды JOIN:
`INNER JOIN` — соединение, которое показывает только те данные из первой таблицы, которым соответствуют некоторые данные из второй таблицы. Остальные — опускаются.
`LEFT JOIN` — соединение, которое показывает все данные из первой таблицы и соответствующие данные из второй, если они есть. Если же соответствующих данных нет, поля для данных из второй таблицы будут пустыми.
`RIGHT JOIN` — соединение, которое показывает все данные из второй таблицы и соответствующие данные из первой, если они есть. Если же соответствующих данных нет, поля для данных из первой таблицы будут пустыми.
`FULL JOIN` — соединение, которое показывает все данные из первой и второй таблицы. Если связанных данных в другой таблице нет, поля для этих данных будут пустыми.
`CROSS JOIN` — перекрестное соединение, при котором каждая строка первой таблицы соединяется с каждой строкой второй таблицы (каждая с каждой). То есть, если в двух таблицах по 3 строки, после данного соединения мы получим результат из 9 строк.

Пример Join(inner):
```postgresql
SELECT *
FROM first_table
INNER JOIN second_table ON first_table.some_column = second_table.some_column
```

![Image alt](https://raw.githubusercontent.com/dianapovarnitsina/java-theory/master/theory/BD/join.png)
![Image alt](https://raw.githubusercontent.com/dianapovarnitsina/java-theory/master/theory/BD/join2.png)


### Что такое свойство ACID в базе данных?

- A — `Атомарность`, гарантирует, что никакая транзакция не фиксируется в системе частично. Выполняются либо все её подоперации, либо ни одной.

```text
К примеру, перевод денег в банке на другой счет — это две операции:
Перевести деньги на счет банка.
Перевести деньги со счета банка на конкретный счет.
Но может всякое случиться. Например, поступят в банк, а дальше выпадет какая-то ошибка и вторая операция не выполнится. 
Или наоборот: выполнится только вторая операция. Поэтому эти действия осуществляются в рамках одной транзакции, и в результате либо всё, либо ничего.

```

- С — `Согласованность`: каждая успешная транзакция всегда фиксирует только разрешаемые результаты.

Это гарантирует, что все ограничения будут соблюдены (например, NOT NULL), иначе — транзакция откатится.

- И — `Изолированность`: во время выполнения транзакции параллельные транзакции не должны оказывать влияние на ее результат.

Это дает нам возможность скрывать от всех не конечные состояния данных. Собственно, поэтому неуспешные транзакции не могут ничего сломать.

- Д — `Долговечность`: если транзакция выполнена, то можно быть уверенным, что внесенные ею изменения не отменятся из-за какого-либо сбоя.

### Уровни изолированности транзакций

Каждый уровень изолированности разрешает/запрещает определенные действия (возможности):

- фантомное чтение — в рамках одной транзакции один и тот же запрос данных дает разные результаты, что происходит из-за добавления данных другой (параллельной) транзакцией.
- неповторяющееся чтение — в рамках одной транзакции один и тот же запрос данных дает разные результаты, что происходит из-за изменения или удаления данных другой (параллельной) транзакцией.
- «грязное» чтение — чтение данных, добавленных или измененных транзакцией, которая впоследствии не откатится;
- потерянное обновление — при одновременном изменении одного блока данных разными транзакциями теряются все изменения, кроме последнего (похоже на “состояние гонки” в многопоточности).

См. ниже табл:
![Image alt](https://raw.githubusercontent.com/dianapovarnitsina/java-theory/master/theory/BD/bd1.png)


### Что такое SQL-инъекция?

`SQL-инъекция` — один из способов взлома сайта, суть которого — внедрение в данные через GET, POST запросы или Cookie некоторого SQL кода. 
Если веб-сайт выполняет такие инъекции, можно получить доступ к БД и взломать приложение.

Например, мы знаем имя некоторой переменной. Допустим, column_name с типом boolean. 
Если система восприимчива к инъекциям, можно добавить OR column_name=true и после этого писать всё, что нам нужно от БД. 
OR создаст условие ИЛИ, и наше выражение после него будет всегда true, что и пропустит нас дальше.

Атака на сайт вроде инъекции SQL возможна из-за неправильной обработки входящих данных, используемых в SQL-запросах.

При соединении с базой данных при помощи JDBC вы используете различные Statements. 
Для повышения безопасности необходимо использовать PreparedStatement вместо обычного Statement, 
так как при использовании Statement строки запроса и значений просто складываются, делая возможными инъекции.

В свою очередь, в PreparedStatement есть конкретный шаблон запроса, и данные в него вставляются с отражением кавычек. 
В итоге SQL-инъекции будут восприниматься только как строковое представление какого-то поля.

Для защиты от SQL-инъекций можно использовать проверку на основе регулярных выражений.

Ещё вариант — установить ограничение на количество символов входящих параметров: например, если вам должно приходить число не более 9999, 
подойдет ограничение в четыре входящих символа. Оно снизит риск взлома с помощью SQL-инъекций.

### Что такое хранимые процедуры? Хранимые функции? Триггер?

***Хранимые процедуры***

`Хранимые процедуры в SQL` — сущность в БД, представляющая собой набор SQL-инструкций, который компилируется один раз и хранится на сервере. 
Словом, это аналог методов в Java.

Хранимые процедуры могут выполнять действия над данными как обычные запросы, так и некоторые действия, недоступные для обычных запросов.

Процедура является сущностью SQL, которую создают один раз, а затем вызывают, передавая аргументы.
Плюс этого подхода состоит в том, что данные инструкции можно переиспользовать не единожды.

Хранимые процедуры увеличивают производительность, расширяют возможности программирования и поддерживают функции безопасности данных.

Рассмотрим создание процедуры:

```postgresql
CREATE PROCEDURE procedure_name (first_param some_type, second_param some_type..)
 begin
……...
 end
```

Вызов процедуры:

```postgresql
CALL procedure_name (first_param, second_param…..);
```


***Хранимая функция***

`Хранимая функция` — это разновидность хранимой процедуры. Отличие функции состоит в том, что она всегда возвращает только единичное значение, а процедура — набор значений.

Хранимые процедуры нельзя смешивать с обычным SQL, в то время как с сохраненной функцией это можно — и это ее преимущество. 
С другой стороны, у хранимых функций гораздо больше ограничений, нежели у процедур.

Создание хранимой функции:

```postgresql
CREATE FUNCTION function_name (first_param, second_param…..)
RETURNS some_type
 begin
……...
RETURN some_value;
end
```

Вызов хранимой функции:

```postgresql
SELECT function_name(first_param, second_param…..);
```

***Триггер***

`Триггер` — еще одна разновидность хранимой процедуры, которая вызывается не непосредственно пользователем, а ее активация происходит при модификации данных. 
То есть эта процедура активируется при выполнении некоторых условий, как, например, INSERT или DELETE, или UPDATE данных в определенном столбце данной таблицы.

Момент запуска триггера определяется с помощью ключевых слов BEFORE (триггер запускается до связанного события) или AFTER (после события).


```postgresql
CREATE TRIGGER trigger_name
ON table_name
AFTER INSERT
 begin
……...
 end
```






### Перечисление существующих БД
```text
Oracle
MySQL 
Microsoft SQL Server 
PostgreSQL 
MongoDB
IBM Db2 
Redis
Microsoft Access 
Cassandra
SQLite 
```








!!!!!!!!! ДОбавить NO SQL