[Вопросы для собеседования](README.md)

# SQL
+ [Что такое _«SQL»_?](#Что-такое-sql)
+ [Синтаксис SQL](#Синтаксис SQL)
+ [Типы данных](#Типы данных)
+ [Какие существуют операторы SQL?](#Какие-существуют-операторы-sql)
+ [Что означает `NULL` в SQL?](#Что-означает-null-в-sql)
+ [Что такое _«временная таблица»_? Для чего она используется?](#Что-такое-временная-таблица-Для-чего-она-используется)
+ [Что такое _«представление» (view)_ и для чего оно применяется?](#Что-такое-представление-view-и-для-чего-оно-применяется)
+ [Каков общий синтаксис оператора `SELECT`?](#Каков-общий-синтаксис-оператора-select)
+ [Что такое `JOIN`?](#Что-такое-join)
+ [Какие существуют типы `JOIN`?](#Какие-существуют-типы-join)
+ [Что лучше использовать `JOIN` или подзапросы?](#Что-лучше-использовать-join-или-подзапросы)
+ [Для чего используется оператор `HAVING`?](#Для-чего-используется-оператор-having)
+ [В чем различие между операторами `HAVING` и `WHERE`?](#В-чем-различие-между-операторами-having-и-where)
+ [Для чего используется оператор `ORDER BY`?](#Для-чего-используется-оператор-order-by)
+ [Для чего используется оператор `GROUP BY`?](#Для-чего-используется-оператор-group-by)
+ [Как `GROUP BY` обрабатывает значение `NULL`?](#Как-group-by-обрабатывает-значение-null)
+ [В чем разница между операторами `GROUP BY` и `DISTINCT`?](#В-чем-разница-между-операторами-group-by-и-distinct)
+ [Что такое функция SQL?](#Что-такое-функция-SQL?)
+ [Перечислите основные агрегатные функции.](#Перечислите-основные-агрегатные-функции)
+ [Функций для работы со строками](#Функций для работы со строками)
+ [Функций для работы с числами](#Функций для работы с числами)
+ [Функций для работы с датой и временем](#Функций для работы с датой и временес)
+ [В чем разница между `COUNT(*)` и `COUNT({column})`?](#В-чем-разница-между-count-и-countcolumn)
+ [Что делает оператор `EXISTS`?](#Что-делает-оператор-exists)
+ [Для чего используются операторы `IN`, `BETWEEN`, `LIKE`?](#Для-чего-используются-операторы-in-between-like)
+ [Для чего применяется ключевое слово `UNION`?](#Для-чего-применяется-ключевое-слово-union)
+ [Какие ограничения на целостность данных существуют в SQL?](#Какие-ограничения-на-целостность-данных-существуют-в-sql)
+ [Какие отличия между ограничениями `PRIMARY` и `UNIQUE`?](#Какие-отличия-между-ограничениями-primary-и-unique)
+ [Может ли значение в столбце, на который наложено ограничение `FOREIGN KEY`, равняться `NULL`?](#Может-ли-значение-в-столбце-на-который-наложено-ограничение-foreign-key-равняться-null)
+ [Индексы](#Индексы)
+ [Как создать индекс?](#Как-создать-индекс)
+ [Кластеризованным и некластеризованный индекс](#В-чем-разница-между-кластеризованным-и-некластеризованным-индексами-в-SQL?)
+ [Что такое составной индекс](#Что такое составной индекс?)
+ [Что такое покрывающий индекс? Уникальный индекс?](#Что-такое-покрывающий-индекс?-Уникальный-индекс?)
+ [Что такое первичный ключ](#Что-такое-первичный-ключ)
+ [Что такое внешний ключ?](#Что-такое-внешний-ключ?)
+ [Что делает оператор `MERGE`?](#Что-делает-оператор-merge)
+ [В чем отличие между операторами `DELETE` и `TRUNCATE`?](#В-чем-отличие-между-операторами-delete-и-truncate)
+ [Что такое _«хранимая процедура»_?](#Что-такое-хранимая-процедура)
+ [Что такое _«триггер»_?](#Что-такое-триггер)
+ [Что такое _«курсор»_?](#Что-такое-курсор)
+ [Опишите разницу типов данных `DATETIME` и `TIMESTAMP`.](#Опишите-разницу-типов-данных-datetime-и-timestamp)
+ [Для каких числовых типов недопустимо использовать операции сложения/вычитания?](#Для-каких-числовых-типов-недопустимо-использовать-операции-сложениявычитания)
+ [Напишите запрос...](#Напишите-запрос)
+ [Ограничения](#Ограничения)
+ [Что такое свойство ACID в базе данных?](#Что-такое-свойство-ACID-в-базе-данных?)
+ [Уровни изолированности транзакций](#Уровни-изолированности-транзакций)
+ [Что такое SQL-инъекция?](#Что-такое-SQL-инъекция?)
+ [Что такое хранимые процедуры? Хранимые функции? Триггер?](#Что-такое-хранимые-процедуры?-Хранимые-функции?-Триггер?)
+ [Перечисление существующих БД](#Перечисление-существующих-БД)



## Что такое _«SQL»_?
SQL, Structured query language («язык структурированных запросов») — формальный непроцедурный язык программирования, применяемый для создания, модификации и управления данными в произвольной реляционной базе данных, управляемой соответствующей системой управления базами данных (СУБД).

[Примеры запросов](examplesSql.md)



## Синтаксис SQL

`Синтаксис` — это уникальный набор правил и рекомендаций.

Все инструкции SQL должны начинаться с ключевого слова, такого как SELECT, INSERT, UPDATE, DELETE, ALTER, DROP, CREATE, USE, SHOW и т.п.
и заканчиваться точкой с запятой (;) (точка с запятой не входит в синтаксис SQL, но ее наличия, как правило, требуют консольные клиенты СУБД для обозначения окончания ввода команды).
SQL не чувствителен к регистру, т.е. SELECT, select и SeLeCt являются идентичными инструкицями.
Исключением из этого правила является MySQL, где учитывается регистр в названии таблицы.

Примеры синтаксиса:

```postgresql
-- выборка
SELECT col1, col2, ...colN
FROM tableName;

SELECT DISTINCT col1, col2, ...colN
FROM tableName;

SELECT col1, col2, ...colN
FROM tableName
WHERE condition;

SELECT col1, col2, ...colN
FROM tableName
WHERE condition1 AND|OR condition2;

SELECT col2, col2, ...colN
FROM tableName
WHERE colName IN (val1, val2, ...valN);

SELECT col1, col2, ...colN
FROM tableName
WHERE colName BETWEEN val1 AND val2;

SELECT col1, col2, ...colN
FROM tableName
WHERE colName LIKE pattern;

SELECT col1, col2, ...colN
FROM tableName
WHERE condition
ORDER BY colName [ASC|DESC];

SELECT SUM(colName)
FROM tableName
WHERE condition
GROUP BY colName;

SELECT COUNT(colName)
FROM tableName
WHERE condition;

SELECT SUM(colName)
FROM tableName
WHERE condition
GROUP BY colName
HAVING (function condition);

-- создание таблицы
CREATE TABLE tableName (
  col1 datatype,
  col2 datatype,
  ...
  colN datatype,
  PRIMARY KEY (одна или более колонка)
);

-- удаление таблицы
DROP TABLE tableName;

-- создание индекса
CREATE UNIQUE INDEX indexName
ON tableName (col1, col2, ...colN);

-- удаление индекса
ALTER TABLE tableName
DROP INDEX indexName;

-- получение описания структуры таблицы
DESC tableName;

-- очистка таблицы
TRUNCATE TABLE tableName;

-- добавление/удаление/модификация колонок
ALTER TABLE tableName ADD|DROP|MODIFY colName [datatype];

-- переименование таблицы
ALTER TABLE tableName RENAME TO newTableName;

-- вставка значений
INSERT INTO tableName (col1, col2, ...colN)
VALUES (val1, val2, ...valN)

-- обновление записей
UPDATE tableName
SET col1 = val1, col2 = val2, ...colN = valN
[WHERE condition];

-- удаление записей
DELETE FROM tableName
WHERE condition;

-- создание БД
CREATE DATABASE [IF NOT EXISTS] dbName;

-- удаление БД
DROP DATABASE [IF EXISTS] dbName;

-- выбор БД
USE dbName;

-- завершения транзакции
COMMIT;

-- отмена изменений
ROLLBACK;
```



## Типы данных

Каждая колонка, переменная и выражение в SQL имеют определенный тип данных (data type). Основные категории типов данных:


***Точные числовые:***

Тип данных	|От	                        |До
------------|---------------------------|----------------------------
bigint	    |-9,223,372,036,854,775,808	|+9,223,372,036,854,775,807
int	        |-2,147,483,648	            |2,147,483,647
smallint	|-32,768	                |32,767
tinyint	    |0	                        |255
bit	        |0	                        |1
decimal	    |-10^38 +1	                |10^38 -1
numeric	    |-10^38 +1	                |10^38 -1
money	    |-922,337,203,685,477.5808	|+922,337,203,685,477.5807
smallmoney	|-214,748.3648	            |+214,748.3647


***Приблизительные числовые***

Тип данных	|От	                        |До
------------|---------------------------|--------------
float	    |-1.79E + 308	            | 1.79E + 308
real	    |-3.40E + 38	            | 3.40E + 38

***Дата и время***

Тип данных	    |От	                        |До
----------------|---------------------------|--------------
datetime	    |Jan 1, 1753	            |Dec 31, 9999
smalldatetime	|Jan 1, 1900	            |Jun 6, 2079
date	        |Дата сохраняется в виде June 30, 1991
time	        |Время сохраняется в виде 12:30 P.M.

***Строковые символьные***

Тип данных	    |От
----------------|---------------------------
char	        |Строка длиной до 8,000 символов (не-юникод символы, фиксированной длины)
varchar	        |Строка длиной до 8,000 символов (не-юникод символы, переменной длины)
text	        |Не-юникод данные переменной длины, длиной до 2,147,483,647 символов

***Строковые символьные (юникод)***

Тип данных	    |От
----------------|---------------------------
nchar	        |Строка длиной до 4,000 символов (юникод символы, фиксированной длины)
nvarchar	    |Строка длиной до 4,000 символов (юникод символы, переменной длины)
ntext	        |Юникод данные переменной длины, длиной до 1,073,741,823 символов

***Бинарные***

Тип данных	    |От
----------------|---------------------------
binary	        |Данные размером до 8,000 байт (фиксированной длины)
varbinary	    |Данные размером до 8,000 байт (переменной длины)
image	        |Данные размером до 2,147,483,647 байт (переменной длины)


***Смешанные***

Тип данных	    |От
----------------|---------------------------
timestamp	    |Уникальные числа, обновляющиеся при каждом изменении строки
uniqueidentifier|Глобально-уникальный идентификатор (GUID)
cursor	        |Объект курсора
table	        |Промежуточный результат, предназначенный для дальнейшей обработки


## Какие существуют операторы SQL?
__операторы определения данных (Data Definition Language, DDL)__:

+ `CREATE` создает объект БД (базу, таблицу, представление, пользователя и т. д.),
+ `ALTER` изменяет объект,
+ `DROP` удаляет объект;

__операторы манипуляции данными (Data Manipulation Language, DML)__:

+ `SELECT` выбирает данные, удовлетворяющие заданным условиям,
+ `INSERT` добавляет новые данные,
+ `UPDATE` изменяет существующие данные,
+ `DELETE` удаляет данные;

__операторы определения доступа к данным (Data Control Language, DCL)__:

+ `GRANT` предоставляет пользователю (группе) разрешения на определенные операции с объектом,
+ `REVOKE` отзывает ранее выданные разрешения,
+ `DENY` задает запрет, имеющий приоритет над разрешением;

__операторы управления транзакциями (Transaction Control Language, TCL)__:

+ `COMMIT` применяет транзакцию,
+ `ROLLBACK` откатывает все изменения, сделанные в контексте текущей транзакции,
+ `SAVEPOINT` разбивает транзакцию на более мелкие.



## Что означает `NULL` в SQL?
`NULL` - специальное значение (псевдозначение), которое может быть записано в поле таблицы базы данных. NULL соответствует понятию «пустое поле», то есть «поле, не содержащее никакого значения».

`NULL` означает отсутствие, неизвестность информации. Значение `NULL` не является значением в полном смысле слова: по определению оно означает отсутствие значения и не принадлежит ни одному типу данных. Поэтому `NULL` не равно ни логическому значению `FALSE`, ни _пустой строке_, ни `0`. При сравнении `NULL` с любым значением будет получен результат `NULL`, а не `FALSE` и не `0`. Более того, `NULL` не равно `NULL`!



## Что такое _«временная таблица»_? Для чего она используется?
__Временная таблица__ - это объект базы данных, который хранится и управляется системой базы данных на временной основе. Они могут быть локальными или глобальными. Используется для сохранения результатов вызова хранимой процедуры, уменьшение числа строк при соединениях, агрегирование данных из различных источников или как замена курсоров и параметризованных представлений.



## Что такое _«представление» (view)_ и для чего оно применяется?
__Представление__, View - виртуальная таблица, представляющая данные одной или более таблиц альтернативным образом.

В действительности представление – всего лишь результат выполнения оператора `SELECT`, который хранится в структуре памяти, напоминающей SQL таблицу. Они работают в запросах и операторах DML точно также как и основные таблицы, но не содержат никаких собственных данных. Представления значительно расширяют возможности управления данными. Это способ дать публичный доступ к некоторой (но не всей) информации в таблице.



## Каков общий синтаксис оператора `SELECT`?
`SELECT` - оператор DML SQL, возвращающий набор данных (выборку) из базы данных, удовлетворяющих заданному условию. Имеет следующую структуру:

```sql
SELECT 
       [DISTINCT | DISTINCTROW | ALL]
       select_expression,...
   FROM table_references
     [WHERE where_definition]
     [GROUP BY {unsigned_integer | column | formula}]
     [HAVING where_definition]
     [ORDER BY {unsigned_integer | column | formula} [ASC | DESC], ...]
```

```sql
SELECT 
    [DISTINCT | ALL]{*
    | [<выражение для столбца> [[AS] <псевдоним>]] [,…]}
FROM <имя таблицы> [[AS] <псевдоним>] [,…]
    [WHERE <предикат>]
    [[GROUP BY <список столбцов>]
    [HAVING <условие на агрегатные значения>] ]
    [ORDER BY <список столбцов>]
```


## Что такое `JOIN`?
__JOIN__ - оператор языка SQL. <br>
Предназначен для обеспечения выборки данных из двух таблиц и включения этих данных в один результирующий набор.

Особенностями операции соединения являются следующее:

+ в схему таблицы-результата входят столбцы обеих исходных таблиц (таблиц-операндов), то есть схема результата является «сцеплением» схем операндов;
+ каждая строка таблицы-результата является «сцеплением» строки из одной таблицы-операнда со строкой второй таблицы-операнда;
+ при необходимости соединения не двух, а нескольких таблиц, операция соединения применяется несколько раз (последовательно).

```sql
SELECT
  field_name [,... n]
FROM
  Table1
  {INNER | {LEFT | RIGHT | FULL} OUTER | CROSS } JOIN
  Table2
    {ON <condition> | USING (field_name [,... n])}
```

Пример:
```postgresql
SELECT 
    maker, Product.model AS model_1, PC.model AS model_2, price
FROM 
    Product 
        INNER JOIN 
    PC 
ON PC.model = Product.model
ORDER BY maker, model_2;
```


## Какие существуют типы `JOIN`?
__(INNER) JOIN__
Результатом объединения таблиц являются записи, общие для левой и правой таблиц. Порядок таблиц для оператора не важен, поскольку оператор является симметричным.

__LEFT (OUTER) JOIN__
Производит выбор всех записей первой таблицы и соответствующих им записей второй таблицы. Если записи во второй таблице не найдены, то вместо них подставляется пустой результат (`NULL`). Порядок таблиц для оператора важен, поскольку оператор не является симметричным.

__RIGHT (OUTER) JOIN__
`LEFT JOIN` с операндами, расставленными в обратном порядке. Порядок таблиц для оператора важен, поскольку оператор не является симметричным.

__FULL (OUTER) JOIN__
Результатом объединения таблиц являются все записи, которые присутствуют в таблицах. Порядок таблиц для оператора не важен, поскольку оператор является симметричным.

__CROSS JOIN (декартово произведение)__
При выборе каждая строка одной таблицы объединяется с каждой строкой второй таблицы, давая тем самым все возможные сочетания строк двух таблиц. Порядок таблиц для оператора не важен, поскольку оператор является симметричным.

![Image alt](https://raw.githubusercontent.com/dianapovarnitsina/java-theory/master/theory/img/join.png)
![Image alt](https://raw.githubusercontent.com/dianapovarnitsina/java-theory/master/theory/img/join2.png)

Пример Join(inner):
```postgresql
SELECT *
FROM first_table
INNER JOIN second_table ON first_table.some_column = second_table.some_column
```

## Что лучше использовать `JOIN` или подзапросы?
Обычно лучше использовать `JOIN`, поскольку в большинстве случаев он более понятен и лучше оптимизируется СУБД (но 100% этого гарантировать нельзя). Так же `JOIN` имеет заметное преимущество над подзапросами в случае, когда список выбора `SELECT` содержит столбцы более чем из одной таблицы.

Подзапросы лучше использовать в случаях, когда нужно вычислять агрегатные значения и использовать их для сравнений во внешних запросах.



## Для чего используется оператор `HAVING`?
`HAVING` используется для фильтрации результата `GROUP BY` по заданным логическим условиям.



## В чем различие между операторами `HAVING` и `WHERE`?
Основное отличие 'WHERE' от 'HAVING' заключается в том, что 'WHERE' сначала выбирает строки, а затем группирует их и вычисляет агрегатные функции (таким образом, она отбирает строки для вычисления агрегатов). <br>
Тогда как 'HAVING' отбирает строки групп после группировки и вычисления агрегатных функций. <br>

Как следствие, предложение 'WHERE' не должно содержать агрегатных функций; не имеет смысла использовать агрегатные функции для определения строк для вычисления агрегатных функций. <br>
Предложение 'HAVING', напротив, всегда содержит агрегатные функции. (Строго говоря, вы можете написать предложение 'HAVING', не используя агрегаты, но это редко бывает полезно.

То же самое условие может работать более эффективно на стадии 'WHERE'.)



## Для чего используется оператор `ORDER BY`?
__ORDER BY__ упорядочивает вывод запроса согласно значениям в том или ином количестве выбранных столбцов. Многочисленные столбцы упорядочиваются один внутри другого. Возможно определять возрастание `ASC` или убывание `DESC` для каждого столбца. По умолчанию установлено - возрастание (ASC).



## Для чего используется оператор `GROUP BY`?
`GROUP BY` используется для агрегации записей результата по заданным признакам-атрибутам.



## Как `GROUP BY` обрабатывает значение `NULL`?
При использовании `GROUP BY` все значения `NULL` считаются равными.



## В чем разница между операторами `GROUP BY` и `DISTINCT`?
`DISTINCT` указывает, что для вычислений используются только уникальные значения столбца. `NULL` считается как отдельное значение.
`GROUP BY` создает отдельную группу для всех возможных значений (включая значение `NULL`).

Если нужно удалить только дубликаты лучше использовать `DISTINCT`, `GROUP BY` лучше использовать для определения групп записей, к которым могут применяться агрегатные функции.



## Что такое функция SQL?
`Функция SQL` — это набор операторов SQL, которые принимают входные данные и выполняют с ними действия SQL, а затем возвращают результаты в виде выходных данных.



## Перечислите основные агрегатные функции.
__Агрегатных функции__ - функции, которые берут группы значений и сводят их к одиночному значению.

SQL предоставляет несколько агрегатных функций:

`COUNT` - производит подсчет записей, удовлетворяющих условию запроса; <br>
`SUM` - вычисляет арифметическую сумму всех значений колонки;  <br>
`AVG` - вычисляет среднее арифметическое всех значений;  <br>
`MAX` - определяет наибольшее из всех выбранных значений;  <br>
`MIN` - определяет наименьшее из всех выбранных значений.  <br>

MIN
```postgresql
SELECT MIN(Price) AS LeastPricy
FROM Products;
```
Эта функция SQL возвращает самую низкую цену из всех продуктов в таблице Products.

MAX
```postgresql
SELECT MAX(Price) AS MostExpensive
FROM Products;
```
Эта функция SQL возвращает самую высокую цену из всех продуктов в таблице Products.

AVG
```postgresql
SELECT AVG(Price) AS AveragePrice
FROM Products;
```
Эта функция SQL возвращает среднюю цену среди всех продуктов в таблице Products.

COUNT
```postgresql
SELECT COUNT(ProductID)
FROM Products;
```
Эта команда возвращает количество продуктов в таблице Products.

SUM
```postgresql
SELECT SUM(Quantity)
FROM OrderDetails;
```
Возвращает сумму всех заказов в таблице Order Details.



## Функций для работы со строками

CONCAT — объединение строк
LENGTH — возвращает количество символов в строке
TRIM — удаляет пробелы в начале и конце строки
LOWER — переводит символы строки в нижний регистр
UPPER — переводит символы строки в верхний регистр и т.д.
http://www.sql-tutorial.ru/ru/book_string_functions_in_sql_server.html



## Функций для работы с числами

ROUND — округляет число
TRUNCATE — обрезает дробное число до указанного количества знаков после запятой
CEILING — возвращает наименьшее целое число, которое больше или равно текущему значению
FLOOR — возвращает наибольшее целое число, которое меньше или равно текущему значению
POWER — возводит число в указанную степень
SQRT — возвращает квадратный корень числа
RAND — генерирует случайное число с плавающей точкой в диапазоне от 0 до 1

http://www.sql-tutorial.ru/ru/book_numeric_functions_in_sql_server.html



## Функций для работы с датой и временем

***C датой:***
CURDATE/CURRENT_DATE — возвращает текущую дату
CURTIME/CURRENT_TIME — возвращает текущее время и т.д.

***Для разбора даты и времени***
DAYOFMONTH(date) — возвращает день месяца в виде числа
DAYOFWEEK(date) — возвращает день недели в виде числа
DAYOFYEAR(date) — возвращает номер дня в году
MONTH(date) — возвращает месяц
YEAR(date) — возвращает год
LAST_DAY(date) — возвращает последний день месяца в виде даты
HOUR(time) — возвращает час
MINUTE(time) — возвращает минуты
SECOND(time) — возвращает секунды и др.

***Для манипулирования датами:***
DATE_ADD(date, interval) — выполняет сложение даты и определенного временного интервала
DATE_SUB(date, interval) — выполняет вычитание из даты определенного временного интервала
DATEDIFF(date1, date2) — возвращает разницу в днях между двумя датами
TO_DAYS(date) — возвращает количество дней с 0-го дня года
TIME_TO_SEC(time) — возвращает количество секунд с полуночи и др.

Для форматирования даты и времени используются функции DATE_FORMAT(date, format) и TIME_FORMAT(date, format), соответственно.

http://www.sql-tutorial.ru/ru/book_tsql_datetime_functions.html



## В чем разница между `COUNT(*)` и `COUNT({column})`?
`COUNT (*)` подсчитывает количество записей в таблице, не игнорируя значение NULL, поскольку эта функция оперирует записями, а не столбцами.

`COUNT ({column})` подсчитывает количество значений в `{column}`. При подсчете количества значений столбца эта форма функции `COUNT` не принимает во внимание значение `NULL`.



## Что делает оператор `EXISTS`?
`EXISTS` берет подзапрос, как аргумент, и оценивает его как `TRUE`, если подзапрос возвращает какие-либо записи и `FALSE`, если нет.



## Для чего используются операторы `IN`, `BETWEEN`, `LIKE`?
`IN` - определяет набор значений.

```sql 
SELECT * FROM Persons WHERE name IN ('Ivan','Petr','Pavel');
```

`BETWEEN` определяет диапазон значений. В отличие от `IN`, `BETWEEN` чувствителен к порядку, и первое значение в предложении должно быть первым по алфавитному или числовому порядку.

```sql 
SELECT * FROM Persons WHERE age BETWEEN 20 AND 25;
```

`LIKE` применим только к полям типа `CHAR` или `VARCHAR`, с которыми он используется чтобы находить подстроки. В качестве условия используются _символы шаблонизации (wildkards_) - специальные символы, которые могут соответствовать чему-нибудь:

+ `_` замещает любой одиночный символ. Например, `'b_t'` будет соответствовать словам `'bat'` или `'bit'`, но не будет соответствовать `'brat'`.

+ `%` замещает последовательность любого числа символов. Например `'%p%t'` будет соответствовать словам `'put'`, `'posit'`, или `'opt'`, но не `'spite'`.

```sql 
SELECT * FROM UNIVERSITY WHERE NAME LIKE '%o';
```



## Для чего применяется ключевое слово `UNION`?
В языке SQL ключевое слово `UNION` применяется для объединения результатов двух SQL-запросов в единую таблицу, состоящую из схожих записей. Оба запроса должны возвращать одинаковое число столбцов и совместимые типы данных в соответствующих столбцах. Необходимо отметить, что `UNION` сам по себе не гарантирует порядок записей. Записи из второго запроса могут оказаться в начале, в конце или вообще перемешаться с записями из первого запроса. В случаях, когда требуется определенный порядок, необходимо использовать `ORDER BY`.



## Какие ограничения на целостность данных существуют в SQL?
`PRIMARY KEY` - набор полей (1 или более), значения которых образуют уникальную комбинацию и используются для однозначной идентификации записи в таблице. Для таблицы может быть создано только одно такое ограничение. Данное ограничение используется для обеспечения целостности сущности, которая описана таблицей.

`CHECK` используется для ограничения множества значений, которые могут быть помещены в данный столбец. Это ограничение используется для обеспечения целостности предметной области, которую описывают таблицы в базе.

`UNIQUE` обеспечивает отсутствие дубликатов в столбце или наборе столбцов.

`FOREIGN KEY` защищает от действий, которые могут нарушить связи между таблицами. `FOREIGN KEY` в одной таблице указывает на `PRIMARY KEY` в другой. Поэтому данное ограничение нацелено на то, чтобы не было записей `FOREIGN KEY`, которым не отвечают записи `PRIMARY KEY`.



## Какие отличия между ограничениями `PRIMARY` и `UNIQUE`?
По умолчанию ограничение `PRIMARY` создает кластерный индекс на столбце, 
а `UNIQUE` - некластерный. 
Другим отличием является то, что `PRIMARY` не разрешает `NULL` записей, в то время как `UNIQUE` разрешает одну (а в некоторых СУБД несколько) `NULL` запись.



## Может ли значение в столбце, на который наложено ограничение `FOREIGN KEY`, равняться `NULL`?
Может, если на данный столбец не наложено ограничение `NOT NULL`.



## Индексы

`Индекс` — отсортированный набор значений, связанных с таблицей или представлением с конкретной колонкой, который ускоряет получение данных.

```postgresql
CREATE INDEX idx_lastname
ON Persons (LastName);
```
То есть это указатель, который помогает нам при поиске по фамилии. <br>
Если использовать эту возможность правильно, можно сильно повысить производительность при работе с большими базами данных. А можно и сильно понизить. <br>

Чтобы ускорить поиск, эти ключи хранятся в виде структуры сбалансированного дерева, по которому выполняется поиск.
Как правило индексы нужно вводить на поля, по которым наиболее часто ведется поиск.
Задумываться о создании индекса нужно не ранее, чем когда у вас появится хотя бы 10 тысяч записей.
В ином случае заметного результата вы не увидите, ибо преждевременная оптимизация — ЗЛО.<br>


***Как индекс может ударить по производительности системы?***<br>
При вставке новых данных или удалении старых структура сбалансированного дерева будет заново пересчитываться.
Собственно, чем больше данных и индексов, тем больше деревьев нужно пересчитать.
Представьте ситуацию: у вас есть порядка 20 000 записей и 7 индексов на эту таблицу.
То есть, при вставке данных нужно заново пересчитать 7 деревьев, в каждом из которых — по 20 000 записей.
Строго говоря, использовать индексы для таблиц, в которые будут часто добавляться/удаляться данные, и вовсе не рекомендуется.
Напоследок отмечу то, что индексы для столбцов, в которых часто встречается значение null, будут не так эффективны, поэтому не стоить их добавлять на такие колонки.



## Как создать индекс?
Индекс можно создать либо с помощью выражения `CREATE INDEX`:
```sql
CREATE INDEX index_name ON table_name (column_name)
```

либо указав ограничение целостности в виде уникального `UNIQUE` или первичного `PRIMARY` ключа в операторе создания таблицы `CREATE TABLE`.



## В чем разница между кластеризованным и некластеризованным индексами в SQL?

***Кластеризованный:***
- Обеспечивает физический порядок по выбранному полю;
- Если у таблицы есть кластеризованный индекс, она называется кластеризованной;
- Нужно не более одного индекса на таблицу;
- В MySQL кластеризованный индекс не задается явно пользователем, так как если вы не определяете PRIMARY KEY для своей таблицы,
  MySQL находит первый индекс UNIQUE, где все ключевые столбцы — NOT NULL, и InnoDB использует его в качестве кластеризованного индекса.

***Некластеризованный:***
- В одной таблице возможно до 999 некластеризованных индексов;
- Содержит указатель на строки с реальными данными в таблице;
- Не обеспечивает физический порядок;
- Для некластеризованных индексов присутствуют отдельные таблицы с отсортированными данными,
  а именно — одна таблица для одного столбца, на котором индекс, поэтому при запросе данных, не входящих в состав данного поля,
  будет сначала выполняться запрос к полю в данной таблице, а только затем — дополнительный запрос к строке в изначальной таблице.
- Создание некластеризованного индекса:

```postgresql
CREATE INDEX index_name ON table_name(column_name)
```



## Что такое составной индекс?

`Составной индекс` — построенный с посыланием на несколько колонок одновременно. Иначе говоря, это комплексный индекс, состоящий из нескольких колонок.

Такие индексы используют, когда в одном запросе фигурирует более одной колонки.

Создание составного индекса:

```postgresql
CREATE INDEX index_name ON table_name(first_column_name, second_column_name, third_column_name)
```

Как правило, эти индексы используются, когда данные в нескольких столбцах логически взаимосвязаны.



## Что такое покрывающий индекс? Уникальный индекс?

`Покрывающий индекс` — это индекс, которого вполне достаточно для ответа на запрос без обращения к самой таблице.
По этому индексу можно достать всю строку данных, но по факту это просто не нужно.

Благодаря тому, что не нужно ходить непосредственно в исходную таблицу, а ответить можно, используя только индекс,
покрывающие индексы немного быстрее в использовании. При этом не стоит забывать, что чем больше колонок,
тем более громоздким и медленным становится сам индекс. Так что злоупотреблять этим не стоит.

Пример создания уникального некластеризованного индекса:

```postgresql
CREATE UNIQUE INDEX index_name ON table_name(column_name)
```



## Что такое первичный ключ
`Первичный ключ (Primary key)` — поле в таблице для идентификации каждой строки в таблице базы данных. Это уникальный, кластеризованный индекс.
В таблице может быть только одно такое поле, и все значения должны быть уникальными.

***Как правило, первичные ключи создаются, при заведении таблицы:***

```postgresql
CREATE TABLE table_name(
column_name int PRIMARY KEY,
...
                       )
```

>К данной колонке автоматически добавится ограничение — NOT NULL.

***Также можно задать ключ и для уже созданной таблицы:***

```postgresql
ALTER TABLE table_name ADD PRIMARY KEY (column_name);
```

Если первичный ключ добавляется способом, описанным выше, то значения полей, задаваемых как первичный ключ (column_name),
проверяется на отсутствие нулевых (также будет добавлено ограничение — NOT NULL).



## Что такое внешний ключ?

`Внешний ключ (Foreign key)` — это свойство, создаваемое для того, чтобы обеспечить связь между таблицами.

Как правило, внешний ключ устанавливается для столбцов в подчиненной таблице и указывает на один из столбцов из главной таблицы.

***Может задаваться как при создании таблицы:***

```postgresql
CREATE TABLE table_name{
column_name int,
…..
    
FOREIGN KEY(column_name) REFERENCES another_table_name(another_table_column_name) }
```


***Так и после создания таблицы:***

```postgresql
ALTER TABLE table_name
ADD FOREIGN KEY(column_name) REFERENCES another_table_name(another_table_column_name));

```

Можно задать `поведение внешнего ключа при манипуляциях с полем`, на которое он ссылается.
Манипуляции могут быть вида ON DELETE и ON UPDATE.

**Возможные варианты поведения:**

CASCADE — с этим свойством будут автоматически удалены или изменены строки из зависимой таблицы при удалении или изменении связанных строк в главной таблице;
SET NULL — при данном свойстве, когда происходит удаление или обновление связанной строки из главной таблицы, будет устанавливаться значение NULL для столбца внешнего ключа;
NO ACTION — отклоняет попытки удалить или изменить строки в главной таблице, если присутствуют связанные строки в зависимой таблице;
RESTRICT — эквивалентно NO ACTION;
SET DEFAULT — при данном свойстве, когда происходит удаление или обновление связанной строки из главной таблицы, будет устанавливаться значение по умолчанию (если оно есть) для столбца внешнего ключа.

Пример использования:

```postgresql
CREATE TABLE table_name{
column_name int,
…..
FOREIGN KEY(column_name) REFERENCES another_table_name(another_table_column_name) ON UPDATE CASCADE ON DELETE CASCADE }
```

Если не будет явно задано поведение для ON DELETE и ON UPDATE, то будет устанавливаться поведение RESTRICT.



## Что делает оператор `MERGE`?
`MERGE` позволяет осуществить слияние данных одной таблицы с данными другой таблицы. При слиянии таблиц проверяется условие, и если оно истинно, то выполняется `UPDATE`, а если нет - `INSERT`. При этом изменять поля таблицы в секции `UPDATE`, по которым идет связывание двух таблиц, нельзя.



## В чем отличие между операторами `DELETE` и `TRUNCATE`?
`DELETE` - оператор DML, удаляет записи из таблицы, которые удовлетворяют критерию `WHERE` при этом задействуются триггеры, ограничения и т.д.

`TRUNCATE` - DDL оператор (удаляет таблицу и создает ее заново. Причем если на эту таблицу есть ссылки `FOREGIN KEY` или таблица используется в репликации, то пересоздать такую таблицу не получится).



## Что такое _«хранимая процедура»_?
__Хранимая процедура__ — объект базы данных, представляющий собой набор SQL-инструкций, который хранится на сервере. Хранимые процедуры очень похожи на обыкновенные процедуры языков высокого уровня, у них могут быть входные и выходные параметры и локальные переменные, в них могут производиться числовые вычисления и операции над символьными данными, результаты которых могут присваиваться переменным и параметрам. В хранимых процедурах могут выполняться стандартные операции с базами данных (как DDL, так и DML). Кроме того, в хранимых процедурах возможны циклы и ветвления, то есть в них могут использоваться инструкции управления процессом исполнения.

Хранимые процедуры позволяют повысить производительность, расширяют возможности программирования и поддерживают функции безопасности данных. В большинстве СУБД при первом запуске хранимой процедуры она компилируется (выполняется синтаксический анализ и генерируется план доступа к данным) и в дальнейшем её обработка осуществляется быстрее.



## Что такое _«триггер»_?
__Триггер (trigger)__ — это хранимая процедура особого типа, которую пользователь не вызывает непосредственно, а исполнение которой обусловлено действием по модификации данных: добавлением, удалением или изменением данных в заданной таблице реляционной базы данных. Триггеры применяются для обеспечения целостности данных и реализации сложной бизнес-логики. Триггер запускается сервером автоматически и все производимые им модификации данных рассматриваются как выполняемые в транзакции, в которой выполнено действие, вызвавшее срабатывание триггера. Соответственно, в случае обнаружения ошибки или нарушения целостности данных может произойти откат этой транзакции.

Момент запуска триггера определяется с помощью ключевых слов `BEFORE` (триггер запускается до выполнения связанного с ним события) или `AFTER` (после события). В случае, если триггер вызывается до события, он может внести изменения в модифицируемую событием запись. Кроме того, триггеры могут быть привязаны не к таблице, а к представлению (VIEW). В этом случае с их помощью реализуется механизм «обновляемого представления». В этом случае ключевые слова `BEFORE` и `AFTER` влияют лишь на последовательность вызова триггеров, так как собственно событие (удаление, вставка или обновление) не происходит.



## Что такое _«курсор»_?
__Курсор__ — это объект базы данных, который позволяет приложениям работать с записями «по-одной», а не сразу с множеством, как это делается в обычных SQL командах.

Порядок работы с курсором такой:

+ Определить курсор (`DECLARE`)
+ Открыть курсор (`OPEN`)
+ Получить запись из курсора (`FETCH`)
+ Обработать запись...
+ Закрыть курсор (`CLOSE`)
+ Удалить ссылку курсора (`DEALLOCATE`). Когда удаляется последняя ссылка курсора, SQL освобождает структуры данных, составляющие курсор.



## Опишите разницу типов данных `DATETIME` и `TIMESTAMP`.
`DATETIME` предназначен для хранения целого числа: `YYYYMMDDHHMMSS`. И это время не зависит от временной зоны, настроенной на сервере.
Размер: 8 байт

`TIMESTAMP` хранит значение равное количеству секунд, прошедших с полуночи 1 января 1970 года по усреднённому времени Гринвича. При получении из базы отображается с учётом часового пояса. Размер: 4 байта



## Для каких числовых типов недопустимо использовать операции сложения/вычитания?
В качестве операндов операций сложения и вычитания нельзя использовать числовой тип `BIT`.



## Напишите запрос...
```sql
CREATE TABLE table ( 
  id BIGINT(20) NOT NULL AUTO_INCREMENT, 
  created TIMESTAMP NOT NULL DEFAULT 0,
  PRIMARY KEY (id) 
);
```

Требуется написать запрос, который вернет максимальное значение `id` и значение `created` для этого `id`:

```sql
SELECT id, created FROM table where id = (SELECT MAX(id) FROM table);
```

---

```sql
CREATE TABLE track_downloads ( 
  download_id BIGINT(20) NOT NULL AUTO_INCREMENT, 
  track_id INT NOT NULL, 
  user_id BIGINT(20) NOT NULL, 
  download_time TIMESTAMP NOT NULL DEFAULT 0, 
  PRIMARY KEY (download_id) 
);
```

Напишите SQL-запрос, возвращающий все пары `(download_count, user_count)`, удовлетворяющие следующему условию: `user_count` — общее ненулевое число пользователей, сделавших ровно `download_count` скачиваний `19 ноября 2010 года`:

```sql
SELECT DISTINCT download_count, COUNT(*) AS user_count 
FROM ( 
    SELECT COUNT(*) AS download_count  
    FROM track_downloads WHERE download_time="2010-11-19" 
    GROUP BY user_id)  
AS download_count
GROUP BY download_count; 
```



## Ограничения

`Ограничения (constraints)` — это правила, применяемые к данным. Они используются для ограничения данных, которые могут быть записаны в таблицу. Это обеспечивает точность и достоверность данных в БД.

Ограничения могут устанавливаться как на уровне колонки, так и на уровне таблицы.

Среди наиболее распространенных ограничений можно назвать следующие:


NOT NULL — колонка не может иметь нулевое значение
DEFAULT — значение колонки по умолчанию
UNIQUE — все значения колонки должны быть уникальными
PRIMARY KEY — первичный или основной ключ, уникальный идентификатор записи в текущей таблице
FOREIGN KEY — внешний ключ, уникальный идентификатор записи в другой таблице (таблице, связанной с текущей)
CHECK — все значения в колонке должны удовлетворять определенному условию
INDEX — быстрая запись и извлечение данных

Любое ограничение может быть удалено с помощью команды ALTER TABLE и DROP CONSTRAINT + название ограничения. Некоторые реализации предоставляют сокращения для удаления ограничений и возможность отключать ограничения вместо их удаления.



## Что такое свойство ACID в базе данных?

- A — `Атомарность`, гарантирует, что никакая транзакция не фиксируется в системе частично. Выполняются либо все её подоперации, либо ни одной.

```text
К примеру, перевод денег в банке на другой счет — это две операции:
Перевести деньги на счет банка.
Перевести деньги со счета банка на конкретный счет.
Но может всякое случиться. Например, поступят в банк, а дальше выпадет какая-то ошибка и вторая операция не выполнится. 
Или наоборот: выполнится только вторая операция. Поэтому эти действия осуществляются в рамках одной транзакции, и в результате либо всё, либо ничего.

```

- С — `Согласованность`: каждая успешная транзакция всегда фиксирует только разрешаемые результаты.

Это гарантирует, что все ограничения будут соблюдены (например, NOT NULL), иначе — транзакция откатится.

- И — `Изолированность`: во время выполнения транзакции параллельные транзакции не должны оказывать влияние на ее результат.

Это дает нам возможность скрывать от всех не конечные состояния данных. Собственно, поэтому неуспешные транзакции не могут ничего сломать.

- Д — `Долговечность`: если транзакция выполнена, то можно быть уверенным, что внесенные ею изменения не отменятся из-за какого-либо сбоя.



## Уровни изолированности транзакций

Каждый уровень изолированности разрешает/запрещает определенные действия (возможности):

- фантомное чтение — в рамках одной транзакции один и тот же запрос данных дает разные результаты, что происходит из-за добавления данных другой (параллельной) транзакцией.
- неповторяющееся чтение — в рамках одной транзакции один и тот же запрос данных дает разные результаты, что происходит из-за изменения или удаления данных другой (параллельной) транзакцией.
- «грязное» чтение — чтение данных, добавленных или измененных транзакцией, которая впоследствии не откатится;
- потерянное обновление — при одновременном изменении одного блока данных разными транзакциями теряются все изменения, кроме последнего (похоже на “состояние гонки” в многопоточности).

См. ниже табл:
![Image alt](https://raw.githubusercontent.com/dianapovarnitsina/java-theory/master/theory/BD/bd1.png)



## Что такое SQL-инъекция?

`SQL-инъекция` — один из способов взлома сайта, суть которого — внедрение в данные через GET, POST запросы или Cookie некоторого SQL кода.
Если веб-сайт выполняет такие инъекции, можно получить доступ к БД и взломать приложение.

Например, мы знаем имя некоторой переменной. Допустим, column_name с типом boolean.
Если система восприимчива к инъекциям, можно добавить OR column_name=true и после этого писать всё, что нам нужно от БД.
OR создаст условие ИЛИ, и наше выражение после него будет всегда true, что и пропустит нас дальше.

Атака на сайт вроде инъекции SQL возможна из-за неправильной обработки входящих данных, используемых в SQL-запросах.

При соединении с базой данных при помощи JDBC вы используете различные Statements.
Для повышения безопасности необходимо использовать PreparedStatement вместо обычного Statement,
так как при использовании Statement строки запроса и значений просто складываются, делая возможными инъекции.

В свою очередь, в PreparedStatement есть конкретный шаблон запроса, и данные в него вставляются с отражением кавычек.
В итоге SQL-инъекции будут восприниматься только как строковое представление какого-то поля.

Для защиты от SQL-инъекций можно использовать проверку на основе регулярных выражений.

Ещё вариант — установить ограничение на количество символов входящих параметров: например, если вам должно приходить число не более 9999,
подойдет ограничение в четыре входящих символа. Оно снизит риск взлома с помощью SQL-инъекций.



## Что такое хранимые процедуры? Хранимые функции? Триггер?

***Хранимые процедуры***

`Хранимые процедуры в SQL` — сущность в БД, представляющая собой набор SQL-инструкций, который компилируется один раз и хранится на сервере.
Словом, это аналог методов в Java.

Хранимые процедуры могут выполнять действия над данными как обычные запросы, так и некоторые действия, недоступные для обычных запросов.

Процедура является сущностью SQL, которую создают один раз, а затем вызывают, передавая аргументы.
Плюс этого подхода состоит в том, что данные инструкции можно переиспользовать не единожды.

Хранимые процедуры увеличивают производительность, расширяют возможности программирования и поддерживают функции безопасности данных.

Рассмотрим создание процедуры:

```postgresql
CREATE PROCEDURE procedure_name (first_param some_type, second_param some_type..)
 begin
……...
 end
```

Вызов процедуры:

```postgresql
CALL procedure_name (first_param, second_param…..);
```


***Хранимая функция***

`Хранимая функция` — это разновидность хранимой процедуры. Отличие функции состоит в том, что она всегда возвращает только единичное значение, а процедура — набор значений.

Хранимые процедуры нельзя смешивать с обычным SQL, в то время как с сохраненной функцией это можно — и это ее преимущество.
С другой стороны, у хранимых функций гораздо больше ограничений, нежели у процедур.

Создание хранимой функции:

```postgresql
CREATE FUNCTION function_name (first_param, second_param…..)
RETURNS some_type
 begin
……...
RETURN some_value;
end
```

Вызов хранимой функции:

```postgresql
SELECT function_name(first_param, second_param…..);
```

***Триггер***

`Триггер` — еще одна разновидность хранимой процедуры, которая вызывается не непосредственно пользователем, а ее активация происходит при модификации данных.
То есть эта процедура активируется при выполнении некоторых условий, как, например, INSERT или DELETE, или UPDATE данных в определенном столбце данной таблицы.

Момент запуска триггера определяется с помощью ключевых слов BEFORE (триггер запускается до связанного события) или AFTER (после события).


```postgresql
CREATE TRIGGER trigger_name
ON table_name
AFTER INSERT
 begin
……...
 end
```


## Перечисление некоторых существующих БД
```text
Oracle
MySQL 
Microsoft SQL Server 
PostgreSQL 
MongoDB
IBM Db2 
Redis
Microsoft Access 
Cassandra
SQLite 
```



Доп ссылки:
https://postgrespro.ru/education/university/sqlprimer
https://postgrespro.ru/education/university/dbtech
https://postgrespro.ru/docs/postgresql/14/index
http://www.sql-tutorial.ru/ru/content.html