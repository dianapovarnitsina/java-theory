### Общие определения

`Объектно-ориентированное программирование или ООП` — это парадигма, в которой программа записывается как набор классов. Каждый класс имеет свои экземпляры, называемые объектами.

`Класс` — это способ описания сущности в целом, определяющий обычное состояние и поведение, зависящее от этого состояния, а также обычные правила взаимодействия с этой сущностью. Формально класс рассматривается как набор данных, таких как поля, атрибуты, члены класса и функции, т.е. методы для работы с ними.

`Класс` – это шаблонная конструкция, которая позволяет описать в программе объект, его свойства (атрибуты или поля класса) и поведение (методы класса).

`Свойство/поля (field)` - это переменная, которая описывает какое-либо из свойств данного класса.

`Метод класса` — это блок кода, состоящий из ряда инструкций, который можно вызывать по его имени. Он обязательно содержит возвращаемый тип, название, аргументы и тело метода.

`Constructor (конструктор)` позволяет создать (сконструировать) объект с начальным состоянием (заданными значениями свойств).<br>
Объекты ВСЕГДА создаются с помощью конструктора, даже если вы сами явно не создавали конструктор (в этом случае компилятор автоматически создает конструктор по-умолчанию без параметров). <br>
Основное назначение конструктора: принять входящие параметры, присвоить их значения в поля объекта и вернуть уже заполненный объект. <br>
Объект может иметь несколько конструкторов (зависит от количества полей). <br>
Имя конструктора должно быть как имя класса (иначе компилятор подумает, что вы хотите создать обычный метод) <br>

`Объект/экземпляр класса (instance)` – воплощение класса. Для каждого объекта выделяется область памяти во время работы приложения.

`Аннотация` – это доп. служебная информация для компилятора.

`Инициализация` означает задать значение.


### Парадигмы

Различные подходы к созданию программ называются парадигмами.
Существуют две основные парадигмы программирования: 
- императивная 
- декларативная. <br>
`Императивная парадигма` фокусируется на достижении результата с помощью пошаговых инструкций, которые последовательно изменяют данные.
Императивная парадигма включает:
- парадигма процедурного программирования: основана на концепции вызовов процедур, в которых операторы структурированы в процедуры (C, Java, C++, ColdFusion, Pascal)
- объектно-ориентированное программирование (Ruby, Java, C++, Python, Simula (первый язык ООП), Smalltalk, Visual Basic .NET, Objective-C.)
- подход к параллельной обработке: достигается за счет совместного использования или распараллеливания инструкций между несколькими процессорами (NESL (один из старейших) и C/C++ (также поддерживается благодаря некоторым библиотечным функциям))
`Декларативная парадигма` фокусируется на задаче и пытается получить ожидаемый результат.
Декларативная парадигма включает в себя: 
- логику (логическое программирование): основанная на математической логике — программы в ней задаются в форме логических утверждений и правил вывода (Пролог, Программирование наборов ответов (ASP) и Datalog)
- функциональность (функциональное программирование) - это парадигма программирования, в которой процесс вычислений интерпретируется как вычисление значений функций. Функция в этом случае аналогична математической. То есть функция, в которой вход — массив, который не изменяется, а выход — новый массив с новыми данными. Это отличает математическую функцию от функции в процедурном программировании, где функция представляет собой последовательность действий, изменяющих исходные данные (JavaScript, Haskell, Scala, Erlang, Lisp, ML, Clojure, OCaml, Common Lisp и F#)
- парадигму базы данных (парадигма програм-я баз данных) методология программирования основана на работе с данными


Java реализует:
- парадигму процедурного программирования
- ооп

![Image alt](https://raw.githubusercontent.com/dianapovarnitsina/java-theory/master/theory/img/paradigms.png)


### Компиляция и запуск

Разработчики пишут исходный код программы в текстовые файлы с соответствующими расширениями (.java).
Компиляторы (javac) переводят исходный код в байт-код Java, хранящийся в .class файлах.
Виртуальная машина Java выполняет байт-код, передавая низкоуровневые команды компьютеру.
Все JVM определяются спецификацией JVM, что обеспечивает независимость программ от платформы.

Важно помнить: код, вводимый в JVM, не зависит от платформы, а код вывода зависит от платформы.

![Image alt](https://raw.githubusercontent.com/dianapovarnitsina/java-theory/master/theory/img/cycle_JVM_programm.png)

### JVM, JRE и JDK

Виртуальная машина Java (JVM) выполняет скомпилированный байт-код.
Java Runtime Environment (JRE) включает в себя JVM и стандартные библиотеки и запускает скомпилированные программы.
Когда вы запускаете скомпилированную программу, JRE объединяет байт-код программы с необходимыми библиотеками и запускает JVM, которая выполняет полученный байт-код.
Java Development Kit (JDK), включающий JRE и средства разработки, используется разработчиками для написания программ.
Он включает в себя JRE для запуска программ и инструментов для разработчиков: компилятор Java, отладчик, архиватор, генератор документации и т. д.

***Связь между JVM, JRE и JDK***

![Image alt](https://raw.githubusercontent.com/dianapovarnitsina/java-theory/master/theory/img/jdk.png)

![Image alt](https://raw.githubusercontent.com/dianapovarnitsina/java-theory/master/theory/img/jdk2.png)

https://hyperskill.org/learn/step/3499

### Наследование 

Чтобы создать новый объект в Java на основании других объектов – можно применять принципы:
- наследование (используется ключевое слово `extends`)
- ассоциация (агрегация/композиция) 
Чаще всего в проекте используется комбинация из этих пунктов. Т.е. одновременно и наследование и ассоциация.

***Наследование*** - позволяет не писать заново весь код, а использовать уже готовые объекты для создания новых.

! Наследоваться можно только от одного родителя. <br>
! Дочерние классы обязательно наследуют все возможности родительских классов из цепочки <br>
! Дочерний класс может расширять свой функционал (добавлять новые переменные, методы и пр.) <br>
! Дочерний класс может переопределять родительские возможности (изменять в себе поведение родителей). Для этого нужно указать аннотацию @Override перед методом<br>
! Родительские классы “не видят” все новшества дочерних (т.к. они находятся выше по цепочке)
! Конструкторы НЕ НАСЛЕДУЮТСЯ в дочерние классы. НО в конструкторе дочернего класса можно вызывать через super любой родительский конструктор и “перекидывать” туда значения из дочернего, чтобы проинициализировать.

Аннотация @Override исключит любые ошибки уже на уровне компиляции, если вы например неверно написали название метода (или допустили другую ошибку).<br>
@Override переопределяет (“затирает”) метод не только первого родит. класса, но и все вышестоящие реализации, если они были.

Возле переопределенных методов показываются спец. иконки со стрелкой вниз, нажав на которые можно увидеть все переопределения данного метода в дочерних классах.
![Image alt](https://raw.githubusercontent.com/dianapovarnitsina/java-theory/master/theory/img/Override.png)


`super` — используется для обращения к базовому классу, а `this` к текущему.<br>

super для метода (super.methodName()) – ищет вверх по цепочке родителей и вызывает первый встреченный @Override метод (или вызывает самый базовый, если не найдет).<br>
super для конструктора (super() ) – ДОЛЖЕН вызывать конструктор только первого верхнего родительского класса – в этом отличие от super метода.<br>
Каждый вышестоящий класс может перекидывать значения в super конструкторы еще выше, пока они не дойдут до того места, где эти свойства объявлены.

***Правила:***
- super конструктор может быть вызван только из дочернего конструктора
- super конструктор можно вызывать только один раз из дочернего конструктора
- вызов super конструктора должен следовать первой строкой в дочернем конструкторе
- super методы можно вызывать как из дочерних методов, так из дочерних конструкторов
- super методы можно вызывать в любой строке, любое количество раз (нет ограничений)
- Из дочернего метода вы не можете вызвать super конструктор

```java
public class Class {

    private int number;
    private String str;
    
    public Class(int number, String str) {
        this.number = number;
        this.str = str;
    }
}


public class Class2 extends Class{
    
    private boolean bol;

    //Без параметров
    public Class2() {
    }
    
    //Параметры только для своих свойств (присвоение через this)
    public Class2(boolean bol) {
        this.bol = bol;
    }
    
    //Параметры только для родительских свойств (присвоение через super)
    public Class2(int number, String str) {
        super(number, str);
    }
    
    //Смешанные параметры – и для своих свойств и для родительских (присвоение и через this и через super)
    public Class2(int number, String str, boolean bol) {
        super(number, str);
        this.bol = bol;
       System.out.println();
    }
}

```

***Связь конструкторов в наследовании*** <br>
Каждый дочерний конструктор должен обязательно быть связан хотя бы с одним из конструкторов первого родительского класса.
Таким образом компилятор должен провести связь по каждому конструктору вверх по цепочке.
`Если мы сами не вызываем super конструктор, то компилятор автоматически пытается вызвать родительский конструктор без параметров с помощью super().`

***Порядок вызова конструкторов:***<br>
При наследовании: сначала вызывается самый верхний конструктор (базового класса) и далее вызовы “идут” вниз по цепочке по дочерним. <br>
Это важно понимать, если у вас выполняется доп. функционал в конструкторах (что лучше стараться не делать, если ест возможность – в конструкторах нежелателен никакой лишний код, кроме присвоения значений).


***Отношения между классами***
1) IS-A: <br>
(наследник) IS-A (родитель)? => (наследник) является (родитель)? => (Лада) является (Машина)? <br>
Дочерний объект обязательно должен утвердительно отвечать на вопрос “является?” по отношению к родителю.
2) HAS-A (отношения основаны на использовании): <br>
   *`Ассоциация` - это способ связи между объектами, когда один объект как то связан с другим. Агрегация и композиция являются частными случаями ассоциации.
   - `Агрегация` - это отношение когда один объект является частью другого. 
   Мягкий вариант, когда внутренний объект может становиться частью любого другого объекта (студент – кабинет) и
   жестко не связан с ними (студент может ходит по разным кабинетам) – в этом случае про внутренний объект говорят слово связан с внешним объектом.
   - `Композиция` - еще более тесная связь, когда объект не только является частью другого объекта, но и вообще не может принадлежать другому объекту.
   Более жесткий вариант – внутренний объект не может существовать без внешнего (человек – сердце) – в этом случае про внутренний объект говорят 
   включен во внешний объект (сердце не может само по себе работать). Еще говорят “объект” является частью другого объекта.
   
```java
// Агрегация:
// Объект класса Halter создается извне Horse и передается в конструктор для установления связи. 
// Если объект класса Horse будет удален, объект класса Halter может и дальше использоваться, если, конечно, на него останется ссылка
public class Horse {
    private Halter halter;

    public Horse(Halter halter) {
        this.halter = halter;
    }
}
```
     
```java
// Композиция:
// Объект класса Halter создается в конструкторе, что означает более тесную связь между объектами. 
// Объект класса Halter не может существовать без создавшего его объекта Horse.
public class Horse {
    private Halter halter;

    public Horse() {
        this.halter = new Halter();
    }
}
```

Во многих книгах почему-то все называют одним словом – композиция (без уточнений связей).
Но можно использовать слова: связан и включен, чтобы сразу понимать о какой связи идет речь (агрегация или композиция).

Внешний объект (еще называют “контейнер”) – может включать в себя любые другие внутренние объекты в любом количестве.
Объекты могут связаны друг с другом как матрешки – один в другом. Один объект может быть для кого контейнером и сам являться частью другого контейнера.


***Как выбрать что использовать*** <br>
Если 2 объекта логичней связать способом “содержит” – значит можно применять ассоциацию (композицию или агрегацию). <br>
Если 2 объекта логичней связать способом “является” – значит можно применять наследование.<br>
Чаще всего в проектах применяется смешанный подход: и ассоциация и наследование.